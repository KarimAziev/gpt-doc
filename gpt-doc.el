;;; gpt-doc.el --- Document Elisp code with GPT -*- lexical-binding: t; -*-

;; Copyright (C) 2023 Karim Aziiev <karim.aziiev@gmail.com>

;; Author: Karim Aziiev <karim.aziiev@gmail.com>
;; URL: https://github.com/KarimAziev/gpt-doc
;; Version: 0.5.0
;; Keywords: lisp docs
;; Package-Requires: ((emacs "27.1"))
;; SPDX-License-Identifier: GPL-3.0-or-later

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Document Elisp code using the GPT API.

;;  Setup

;; To use this library, you need to have an OpenAI API key. You can either set
;; `gpt-doc-api-key' as a string directly or define a function that returns the API key.


;;; Single commands:

;; Run at the beginning or inside the function to generate documentation:

;; 'gpt-doc' Generate and insert documentation for a definition at the point. Optional
;; prefix argument determines whether to include related definitions in the GPT
;; system prompt.

;;     If omitted, the value of the custom variable 'gpt-doc-default-context-strategy' will be used as the default.
;;     If it is 1, no related definitions are included.
;;     If it is 4 (shallow), include related definitions that are directly used
;;     in the definition being documented (e.g., functions called within the
;;     function).
;;     If it is 16 (all), recursively include all related definitions, expanding
;;     the documentation context.

;; 'gpt-doc-with-context' Works the same as 'gpt-doc', but by default, it includes shallow related definitions.

;; 'gpt-doc-with-full-context' Works the same as 'gpt-doc', but by default, it includes all related definitions.


;; Batch commands:

;; These commands operate on multiple definitions in the current buffer. They
;; can be called with a prefix argument, which has the same meaning as in
;; 'gpt-doc'.

;; - 'gpt-doc-regenerate-dups'
;;     Regenerate documentation for definitions with duplicate documentation
;;     strings.

;; - 'gpt-doc-document-all-undocumented'
;;     Generate documentation for all undocumented definitions in the buffer.

;; - 'gpt-doc-redocument-all'
;;     Regenerate documentation for all definitions backward starting from the
;;     current one. If there is no suitable definition at the point, start from
;;     the last one in the buffer.


;;; Code:

(defvar json-object-type)
(defvar json-array-type)
(defvar json-false)
(defvar json-null)
(defvar url-request-method)
(defvar url-request-data)
(defvar url-request-extra-headers)
(defvar url-http-end-of-headers)
(defvar gpt-doc-load-filename (or load-file-name buffer-file-name))

(declare-function url-host "url-parse")
(declare-function json-encode "json")
(declare-function json-read "json")
(declare-function json-read-from-string "json")
(declare-function auth-source-search "auth-source")

(require 'subr-x)

(defgroup gpt-doc nil
  "Document Elisp code with GPT."
  :prefix "gpt-doc-"
  :group 'maint)

(defcustom gpt-doc-api-key ""
  "An OpenAI API key (string).

Can also be a function of no arguments that returns an API
key (more secure)."
  :group 'gpt-doc
  :type '(radio
          (string :tag "API key")
          (function-item gpt-doc-api-key-from-auth-source)
          (function :tag "Function that returns the API key")))

(defcustom gpt-doc-gpt-temperature 0.1
  "The temperature for the OpenAI GPT model used.

This is a number between 0.0 and 2.0 that controls the randomness
of the response, with 2.0 being the most random.

The temperature controls the randomness of the output generated by the model. A
lower temperature results in more deterministic and less random completions,
while a higher temperature produces more diverse and random completions.

To adjust the temperature, set the value to the desired level. For example, to
make the model's output more deterministic, reduce the value closer to 0.1.
Conversely, to increase randomness, raise the value closer to 1.0."
  :group 'gpt-doc
  :type 'number)

(defcustom gpt-doc-use-stream t
  "Whether to use streaming responses from the OpenAI API.

When non-nil, responses are streamed, allowing for the cancellation of
long-running requests with `gpt-doc-abort-all'.

When nil, requests are synchronous and must complete before any further actions
can be taken."
  :group 'gpt-doc
  :type 'boolean)

(defcustom gpt-doc-gpt-model "o3-mini"
  "A string variable representing the API model for OpenAI."
  :group 'gpt-doc
  :type 'string)

(defcustom gpt-doc-debug nil
  "Whether to enable debugging in the GPT documentation group."
  :group 'gpt-doc
  :type 'boolean)

(defcustom gpt-doc-default-context-strategy 4
  "Default argument for `gpt-doc' command.

It determines whether to include related buffer definitions used in the thing
being documented:

- If it is 1, no related definitions are included.
- If it is 4 (shallow), include related definitions that are directly used in
  the definition being documented (e.g., functions called within the function).
- If it is 16 (all), include not only shallow related definitions but also their
  nested related definitions recursively, expanding the documentation context."
  :group 'gpt-doc
  :type '(radio
          (const
           :tag "None"
           :doc "No related definitions are included"
           1)
          (const
           :tag
           "Shallow definitions (e.g., functions called within the function)"
           :doc
           "Include related definitions that are directly used in the definition being documented"
           4)
          (const
           :tag "All related definitions"
           :doc
           "Include not only shallow related definitions but also their nested related definitions recursively"
           16)))

(defcustom gpt-doc-gpt-url "https://api.openai.com/v1/chat/completions"
  "The URL to the OpenAI GPT API endpoint for chat completions."
  :group 'gpt-doc
  :type 'string)

(defcustom gpt-doc-variable-prompt "Write a very short documentation that starts with noun about the variable %s in maximum *75* characters. Don't use phrases like \"in Emacs\", \"in Emacs Lisp\" and so on. Don't mention the variable name, customization group, and the parts of the source code. Do NOT wrap the start and end of your text in quotes.

Examples:

Alist of elements (NAME . CONTENTS), one for each Emacs register.
Whether to enable debugging.
Keymap for keyboard macro commands.
Current keyboard macro counter."
  "System prompt (directive) for ChatGPT to document Elisp variables."
  :group 'gpt-doc
  :type 'string)

(defcustom gpt-doc-first-sentence-doc-prompt "The user will provide you an Emacs Lisp code.
Write a very short sentence that starts with imperative verb about what the %s below does in maximum *75* characters.
Don't use phrases like \"in Emacs\", \"in Emacs Lisp\", in `%s' and so on.
Do NOT wrap the start and end of your text in quotes.
Examples:

Read a string in the minibuffer, with completion and PROMPT.
Return STRING propertized as an error message.
Read per-directory file-local variable's mode using completion.
Return an updated collection COLL, associating values with keys KVS.
Return the keys in the collection COLL.
Return updated LIST with KEYS removed."
  "System prompt to generate first sentence of function documentation."
  :group 'gpt-doc
  :type 'string)

(defcustom gpt-doc-args-prompt "The user will provide you an Emacs Lisp code.
Provide a sentence for every argument of %s that starts either with \"Argument \",  \"Optional argument \", \"Remaining arguments\" or \"Arguments \" description such as type, default value without any additional text, prompt or note.

Sentences should be separated by two newline characters.
1. Do NOT wrap the start and end of your text in quotes.
2. Make sure that your text doesn't exceed 70 columns in width.
3. Don't use phrases like \"in Emacs\", \"in Emacs Lisp\", \"this function\",
\"you\" and so on.

Failure to comply with these rules will result in an error.

Example 1:
```elisp
(defun km-call-process (program &rest args)
  (with-temp-buffer
    (let ((status (apply #'call-process program nil t nil
                         (flatten-list args))))
      (let ((result (string-trim (buffer-string))))
        (if (zerop status)
            result
          (message result) nil)))))
```
Argument PROGRAM is the shell command to run.

Remaining arguments ARGS are strings passed as command arguments to PROGRAM.

Example 2:
```elisp
(defun gpt-doc--json-parse-string (str &optional object-type array-type null-object false-object) (if (and (fboundp 'json-parse-string) (fboundp 'json-available-p) (json-available-p)) (json-parse-string str :object-type (or object-type 'alist) :array-type (pcase array-type ('list 'list) ('vector 'array) (_ 'array)) :null-object (or null-object :null) :false-object (or false-object :false)) (require 'json) (let ((json-object-type (or object-type 'alist)) (json-array-type (pcase array-type ('list 'list) ('array 'vector) (_ 'vector))) (json-null (or null-object :null)) (json-false (or false-object :false))) (json-read-from-string str))))
```
The argument OBJECT-TYPE is the type is used
to represent objects; it can be `hash-table', `alist' or `plist'.  It
defaults to `alist'.

The argument ARRAY-TYPE specifies which Lisp type is used
to represent arrays; `array'/`vector' and `list'.

The argument NULL-OBJECT specifies which object to use
to represent a JSON null value.  It defaults to `:null'.

The argument FALSE-OBJECT specifies which object to use to
represent a JSON false value.  It defaults to `:false'."
  "System prompt for ChatGPT to document Elisp arguments."
  :group 'gpt-doc
  :type 'string)

(defcustom gpt-doc-special-prompts (list
                                    (cons 'defcustom "Write a documentation for the custom variable %s, describe the type, and how to use it
without any additional text, prompt, note or the source code. Your text will be inserted as
documentation string in this variables, so follow Emacs rules.

Sentences should be separated by two newline characters.
1. Do NOT wrap the start and end of your text in quotes.
2. Don't mention the name of this variable.
2. Make sure that your text doesn't exceed 70 columns in width.
3. Don't use phrases like \"in Emacs\", \"in Emacs Lisp\", \"this variable\", \"customization group\",
\"you\", :group, :type and so on.

Failure to comply with these rules will result in an error.

Example:

A list of sections to extract from `package.json' when evaluating
JavaScript projects. The default sections are \"dependencies\",
\"devDependencies\", and \"peerDependencies\".

Each element in the list should be a string representing a key in the
`package.json' file that corresponds to a section containing module
dependencies.")
                                    (cons 'defgroup "Write a documentation string for the custom group %s without any additional text, prompt, note or the source code.
Your text will be inserted as documentation string in this variables, so follow Emacs rules.

Sentences should be separated by two newline characters.
1. Do NOT wrap the start and end of your text in quotes.
2. Don't mention the name of this variable.
2. Make sure that your text doesn't exceed 70 columns in width.
3. Don't use phrases like \"defines\", \"in Emacs\", \"in Emacs Lisp\", \"this variable\", \"customization group\",
\"you\", :group, :type and so on.")
                                    (cons 'define-minor-mode
                                          "Write a documentation string for the minor mode %s using imperative verb about what the %s below does. Don't use phrases like \"in Emacs\", \"in Emacs Lisp\", in `%s' and so on. Write only documnentation string and only documentation string. Do NOT wrap the start and end of your text in quotes.")
                                    (cons 'define-derived-mode
                                          "Write a documentation string for the derivered mode %s using imperative verb about what the %s below does. Don't use phrases like \"in Emacs\", \"in Emacs Lisp\", in `%s' and so on. Write only documnentation string and only documentation string. Do NOT wrap the start and end of your text in quotes."))
  "Alist of definition types and corresponding addional prompts.

In prompts %s occurences will be substituted with the name of sexp to document."
  :type '(alist
          :key-type (symbol :tag "Symbol")
          :value-type (string :tag "Prompt"))
  :group 'gpt-doc)

(defcustom gpt-doc-return-type-prompt "Write description using only imperative verbs about the structure of result of calling the function %s. Don't use phrases like \"in Emacs\", \"in Emacs Lisp\" and so on. Don't mention the function name. Do NOT wrap the start and end of your text in quotes.

Examples:

Return STRING propertized as an error message.
Return the value MAP mapped to KEY, NOT-FOUND or nil if key not present.
Return an updated collection COLL, associating values with keys KVS.
Return the keys in the collection COLL.
Return the values in the collection COLL.
Return updated LIST with KEYS removed.
Return updated TABLE with KEYS removed.
Return an updated version of collection COLL with the KEY removed."
  "System prompt to generate return type of function documentation."
  :group 'gpt-doc
  :type 'string)

(defcustom gpt-doc-abort-on-keyboard-quit-count 3
  "Number of `keyboard-quit' presses before aborting GPT documentation requests.

Determines the number of consecutive `keyboard-quit' commands needed to abort an
active streaming request.

The default value is 3, meaning that pressing `keyboard-quit' three times in
quick succession will abort the request.

This variable is only effective when `gpt-doc-use-stream' is non-nil, as it
applies to streaming requests.

If the number of `keyboard-quit' commands does not reach the set threshold, the
abort action will not be triggered."
  :group 'gpt-doc
  :type 'integer)

(defcustom gpt-doc-allow-abort-mode nil
  "Flag to permit cancellation of ongoing documentation streaming.

Determines whether to enable `gpt-doc-mode' to monitor and handle
`keyboard-quit' commands for aborting GPT documentation requests during the
streaming of documentation.

When non-nil, pressing `\\[keyboard-quit]' multiple times can trigger the
cancellation of ongoing documentation generation processes.

See also custom variable `gpt-doc-abort-on-keyboard-quit-count' for exact
number of `keyboard-quit' presses to abort."
  :group 'gpt-doc
  :type 'boolean)

(defcustom gpt-doc-docstring-positions (list
                                        (cons 'defun 3)
                                        (cons 'defmacro 3)
                                        (cons 'defsubst 3)
                                        (cons 'defcustom 3)
                                        (cons 'defgroup 3)
                                        (cons 'define-skeleton 2)
                                        (cons 'define-compilation-mode 3)
                                        (cons 'define-minor-mode 2)
                                        (cons 'define-derived-mode 4)
                                        (cons 'define-generic-mode 8)
                                        (cons 'cl-defun 3)
                                        (cons 'cl-defsubst 3)
                                        (cons 'cl-defmacro 3)
                                        (cons 'cl-defgeneric 3)
                                        (cons 'cl-defmethod
                                              'gpt-doc-forward-to-cl-defmethods-args)
                                        (cons 'defalias 3)
                                        (cons 'defvar-local 3)
                                        (cons 'defvar 3)
                                        (cons 'defconst 3)
                                        (cons 'defhydra 4)
                                        (cons 'define-widget 3)
                                        (cons 'transient-define-suffix 3)
                                        (cons 'transient-define-argument
                                              3)
                                        (cons 'transient-define-prefix 3)
                                        (cons 'ert-deftest 3))
  "An alist that maps definition types to their respective documentation positions.
If the value of cell is a number, move forward across N balanced expressions.
If the value is a function, it will be called with definition sexp and should
return number to move forward across."
  :group 'gpt-doc
  :type '(alist
          :key-type symbol
          :value-type (choice
                       (number :tag "Documentation position")
                       (function :tag "Custom function"))))

(defcustom gpt-doc-prompt-types (list
                                 (cons 'defun "function")
                                 (cons 'defmacro "macro")
                                 (cons 'defsubst "inline function")
                                 (cons 'defcustom "custom variable")
                                 (cons 'defgroup "customization group")
                                 (cons 'define-skeleton "skeleton")
                                 (cons 'define-compilation-mode
                                       "compilation mode")
                                 (cons 'define-minor-mode "minor mode")
                                 (cons 'define-derived-mode "major mode")
                                 (cons 'define-generic-mode "generic mode")
                                 (cons 'cl-defun "function")
                                 (cons 'cl-defsubst "fuction")
                                 (cons 'cl-defmacro "macro")
                                 (cons 'cl-defgeneric "generic")
                                 (cons 'cl-defmethod "method")
                                 (cons 'defalias "alias")
                                 (cons 'defhydra "hydra")
                                 (cons 'define-widget "widget")
                                 (cons 'transient-define-suffix
                                       "transient suffix command")
                                 (cons 'transient-define-argument
                                       "transient argument command")
                                 (cons 'transient-define-prefix
                                       "transient prefix")
                                 (cons 'ert-deftest "test"))
  "An alist that maps definition types to their respective documentation labels."
  :group 'gpt-doc
  :type '(alist
          :key-type symbol
          :value-type string))

(defun gpt-doc-goto-char (position)
  "Jump to POSITION in all windows displaying the buffer.

Argument POSITION is the buffer position to go to."
  (goto-char position)
  (dolist (wnd (get-buffer-window-list (current-buffer) nil t))
    (set-window-point wnd position)))

(defun gpt-doc--debug-log (&rest args)
  "Log debug messages when `gpt-doc-debug' is true.

Argument ARGS is a list of arguments for `message'."
  (when gpt-doc-debug
    (let ((buff (get-buffer-create "*gpt-doc-debug*")))
      (with-current-buffer buff
        (buffer-disable-undo)
        (setq truncate-lines nil)
        (let ((inhibit-read-only t))
          (when-let* ((quit-key (where-is-internal
                                 'quit-window
                                 special-mode-map
                                 t t t))
                      (map (make-sparse-keymap)))
            (define-key map quit-key #'quit-window)
            (define-key map (kbd "E") #'erase-buffer)
            (use-local-map (make-composed-keymap
                            map
                            (current-local-map))))
          (let ((pos (point-max)))
            (goto-char pos)
            (let* ((tm (current-time))
                   (msg (concat
                         "\n"
                         (propertize
                          (format (concat "%s.%06d \n")
                                  (format-time-string "%H:%M:%S" tm)
                                  (nth 2 tm))
                          'face 'font-lock-comment-face)
                         (apply #'format args)
                         "\n"))
                   (inhibit-message t))
              (insert msg))
            (dolist (wnd (get-buffer-window-list buff nil t))
              (with-selected-window wnd
                (set-window-point wnd pos)
                (recenter)))))))))

(defun gpt-doc--show-debug-buffer ()
  "Display debug buffer, fit to content, read-only, with quit key."
  (interactive)
  (let ((buff (get-buffer "*gpt-doc-debug*")))
    (unless buff
      (user-error "No debug buffer"))
    (unless (get-buffer-window buff)
      (with-current-buffer buff
        (pop-to-buffer buff)))))

(defvar gpt-doc--request-url-buffers nil
  "Alist of active request buffers requests.")

(defun gpt-doc-move-with (fn &optional n)
  "Move by calling FN N times.
Return new position if changed, nil otherwise."
  (unless n (setq n 1))
  (with-syntax-table emacs-lisp-mode-syntax-table
    (when-let* ((str-start (nth 8 (syntax-ppss (point)))))
      (goto-char str-start))
    (let ((init-pos (point))
          (pos)
          (count n))
      (while (and (not (= count 0))
                  (when-let* ((end (ignore-errors
                                    (funcall fn)
                                    (point))))
                    (unless (= end (or pos init-pos))
                      (setq pos end))))
        (setq count (1- count)))
      (if (= count 0)
          pos
        (goto-char init-pos)
        nil))))

(defun gpt-doc-backward-up-list (&optional arg)
  "Move backward up across ARG balanced group of parentheses.
Return new position if changed, nil otherwise."
  (gpt-doc-move-with #'backward-up-list arg))

(defun gpt-doc-elisp-bounds-of-def-sexp ()
  "Return the bounds of the nearest parent defintion.
Argument SYMBOLS is an optional list of symbols to match against.
Return a cons cell containing the start and end positions of the defun sexp."
  (let ((result))
    (save-excursion
      (while (progn (setq result (let ((sexp
                                        (sexp-at-point)))
                                   (when
                                       (and sexp
                                            (proper-list-p sexp)
                                            (assq (car sexp)
                                                  gpt-doc-docstring-positions)
                                            (> (length sexp) 2))
                                     (when-let* ((beg (point))
                                                 (end (gpt-doc-forward-sexp 1)))
                                       (cons beg end)))))
                    (and (not result)
                         (gpt-doc-backward-up-list)))))
    result))

(defun gpt-doc-json--read-buffer (&optional object-type array-type null-object
                                            false-object)
  "Parse json from the current buffer using specified object and array types.

The argument OBJECT-TYPE specifies which Lisp type is used
to represent objects; it can be `hash-table', `alist' or `plist'.  It
defaults to `alist'.

The argument ARRAY-TYPE specifies which Lisp type is used
to represent arrays; `array'/`vector' and `list'.

The argument NULL-OBJECT specifies which object to use
to represent a JSON null value.  It defaults to `:null'.

The argument FALSE-OBJECT specifies which object to use to
represent a JSON false value.  It defaults to `:false'."
  (if (and (fboundp 'json-parse-string)
           (fboundp 'json-available-p)
           (json-available-p))
      (json-parse-buffer
       :object-type (or object-type 'alist)
       :array-type
       (pcase array-type
         ('list 'list)
         ('vector 'array)
         (_ 'array))
       :null-object (or null-object :null)
       :false-object (or false-object :false))
    (let ((json-object-type (or object-type 'alist))
          (json-array-type
           (pcase array-type
             ('list 'list)
             ('array 'vector)
             (_ 'vector)))
          (json-null (or null-object :null))
          (json-false (or false-object :false)))
      (json-read))))

(defun gpt-doc--json-parse-string (str &optional object-type array-type
                                       null-object false-object)
  "Parse STR with natively compiled function or with json library.

The argument OBJECT-TYPE specifies which Lisp type is used
to represent objects; it can be `hash-table', `alist' or `plist'.  It
defaults to `alist'.

The argument ARRAY-TYPE specifies which Lisp type is used
to represent arrays; `array'/`vector' and `list'.

The argument NULL-OBJECT specifies which object to use
to represent a JSON null value.  It defaults to `:null'.

The argument FALSE-OBJECT specifies which object to use to
represent a JSON false value.  It defaults to `:false'."
  (if (and (fboundp 'json-parse-string)
           (fboundp 'json-available-p)
           (json-available-p))
      (json-parse-string str
                         :object-type (or object-type 'alist)
                         :array-type
                         (pcase array-type
                           ('list 'list)
                           ('vector 'array)
                           (_ 'array))
                         :null-object (or null-object :null)
                         :false-object (or false-object :false))
    (require 'json)
    (let ((json-object-type (or object-type 'alist))
          (json-array-type
           (pcase array-type
             ('list 'list)
             ('array 'vector)
             (_ 'vector)))
          (json-null (or null-object :null))
          (json-false (or false-object :false)))
      (json-read-from-string str))))

(defun gpt-doc-api-key-from-auth-source (&optional url)
  "Return the fist API key from the auth source for URL.
By default, the value of `gpt-doc-gpt-url' is used as URL."
  (require 'auth-source)
  (require 'url-parse)
  (if-let* ((url-obj (url-generic-parse-url (or url gpt-doc-gpt-url)))
            (host (url-host url-obj))
            (secret (plist-get (car (auth-source-search
                                     :host host
                                     :require '(:secret)))
                               :secret)))
      (if (functionp secret)
          (encode-coding-string (funcall secret) 'utf-8)
        secret)
    (user-error "No `gpt-doc-api-key' found in the auth source")))

(defun gpt-doc-get-api-key ()
  "Return the value of `gpt-doc-api-key' if it is a function.
If it is a string, prompt the user for a key, save it, and renturn the key.
If `gpt-doc-api-key' is not set, raise an error."
  (pcase gpt-doc-api-key
    ((pred functionp)
     (funcall gpt-doc-api-key))
    ((pred stringp)
     (while (string-empty-p gpt-doc-api-key)
       (let ((key (read-string "GPT Api Key: ")))
         (customize-set-value 'gpt-doc-api-key key)
         (when (yes-or-no-p "Save this key?")
           (customize-save-variable 'gpt-doc-api-key key))))
     gpt-doc-api-key)
    (_ (error "`gpt-doc-api-key' is not set"))))

(defun gpt-doc-gpt-request (gpt-prompt system-prompt)
  "Return the response from a request to the OpenAI API.
Argument GPT-PROMPT is the prompt for the GPT model.
Argument SYSTEM-PROMPT is the prompt for the system role."
  (require 'url)
  (let* ((url-request-method "POST")
         (url-request-extra-headers
          `(("Content-Type" . "application/json")
            ("Authorization" . ,(format "Bearer %s"
                                 (gpt-doc-get-api-key)))))
         (data `((model . ,gpt-doc-gpt-model)
                 (messages .
                  ,(apply #'vector
                    `(((role . "system")
                       (content . ,(string-to-unibyte
                                    (encode-coding-string
                                     system-prompt
                                     'utf-8))))
                      ((role . "user")
                       (content .
                        ,(string-to-unibyte
                          (encode-coding-string
                           gpt-prompt
                           'utf-8)))))))
                 (temperature . ,gpt-doc-gpt-temperature)))
         (url-request-data
          (json-encode data))
         (buffer (url-retrieve-synchronously
                  gpt-doc-gpt-url nil 'silent))
         (response (gpt-doc--json-parse-string
                    (with-current-buffer buffer
                      (buffer-substring-no-properties
                       url-http-end-of-headers (point-max))))))
    (gpt-doc--debug-log "gpt-doc: response %s"
                        response)
    (if (not buffer)
        (error "Failed to send request to OpenAI API")
      (condition-case gpt-err
          (if (assoc 'error response)
              (error
               (cdr (assoc 'message (cdr (assoc 'error response)))))
            response)
        (error "Error while parsing API response: %s"
               (error-message-string gpt-err))))))

(defun gpt-doc-response-text (response)
  "Return the RESPONSE text from a GPT API response.
Argument RESPONSE is the alist."
  (cdr
   (assq 'content
         (cdr
          (assq 'message
                (elt
                 (cdr
                  (assq 'choices
                        response))
                 0))))))

(defun gpt-doc-upcased-p (string)
  "Return non-nil if STRING has no lowercase."
  (string= (upcase string) string))

(defun gpt-doc-symbol-p (elem)
  "Return whether the given element ELEM is a non-nil symbol.
Argument ELEM is the element to be checked."
  (and elem
       (not (eq elem t))
       (symbolp elem)))

(defun gpt-doc-extract-sym (sexp arg)
  "Return the symbol extracted from the given SEXP and argument.
Argument SEXP is the s-expression from which the symbol is extracted.
Argument ARG is the argument used to extract the symbol from the SEXP."
  (let ((sym
         (pcase (car sexp)
           ((or 'cl-defun 'cl-defmethod)
            (if (consp arg)
                (car arg) arg))
           (_ arg))))
    (when (gpt-doc-symbol-p sym)
      sym)))

(defun gpt-doc-get-args (sexp)
  "Return a list of arguments extracted from a function/macro definition.
Argument SEXP is the function/macro definition sexp."
  (when (and (proper-list-p sexp)
             (assq (car-safe sexp)
                   gpt-doc-docstring-positions)
             (not (memq (car sexp)
                        '(defcustom defvar defvar-keymap
                           defvar-local defconst))))
    (let ((args (seq-find #'proper-list-p sexp)))
      (let (elems)
        (if (catch 'not-arg
              (while (consp args)
                (let* ((elem (pop args))
                       (sym (gpt-doc-extract-sym sexp elem)))
                  (if
                      (and sym
                           (or (not args)
                               (consp args)))
                      (push sym elems)
                    (throw 'not-arg t)))))
            nil
          (seq-remove
           (lambda (it)
             (let ((name (symbol-name it)))
               (or (string-prefix-p "&"
                                    name)
                   (string-prefix-p "_"
                                    name))))
           (nreverse elems)))))))

(defun gpt-doc-quote-symbols ()
  "Replace `hyphen-separated' symbols in a string with quoted versions."
  (while (re-search-forward
          "\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+[-]\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)"
          nil t 1)
    (let ((arg (match-string-no-properties 0))
          (beg (match-beginning 0))
          (end (match-end 0)))
      (when (member (char-to-string (char-before beg)) '("'" "`"))
        (setq beg (1- beg)))
      (when (member (char-to-string (char-after end)) '("'" "`"))
        (setq end (1+ end)))
      (unless (gpt-doc-upcased-p arg)
        (delete-region beg end)
        (insert (format "`%s'" arg))))))

(defun gpt-doc-quote-args (text)
  "Extracts and formats quoted arguments in a given TEXT.

Argument TEXT is a string that represents the text to be processed."
  (with-temp-buffer
    (insert text)
    (goto-char (point-min))
    (gpt-doc-quote-symbols)
    (buffer-string)))

(defun gpt-doc-get-args-names (sexp)
  "Extract and return argument names from a given s-expression SEXP.

Argument SEXP is a symbolic expression in Emacs Lisp."
  (mapcar #'symbol-name
          (gpt-doc-get-args sexp)))

(defun gpt-doc-upcase-arg-list (doc-str args)
  "Convert occurrences of arguments ARGS in a string DOC-STR to uppercase.

Argument DOC-STR is a string that represents the documentation string to be
processed.
Argument ARGS is a list of arguments that will be used in the regular
expression."
  (let ((regex (regexp-opt (mapcar (lambda (a)
                                     (if (symbolp a)
                                         (symbol-name a)
                                       a))
                                   args)
                           'symbols)))
    (with-temp-buffer
      (insert doc-str)
      (goto-char (point-min))
      (while (re-search-forward regex nil t 1)
        (let ((beg (match-beginning 0))
              (end (match-end 0)))
          (if
              (looking-back "\\(\\_<.+\\_>\\)\\([^.]+\\)\\_<\\(\\(\\1\\)\\)\\_>"
                            0)
              (downcase-region beg end)
            (upcase-region beg end))
          (while (looking-at "[`']")
            (delete-char 1))
          (save-excursion
            (goto-char beg)
            (while (looking-back "[`']" 0)
              (delete-char -1)))))
      (buffer-string))))

(defun gpt-doc--upcase-args (sexp str)
  "Return the STR with all arguments of SEXP upcased.

Argument SEXP is the s-expression to extract argument names from.

Argument STR is the string to upcase arguments in."
  (if-let* ((args-names (mapcar #'symbol-name
                               (gpt-doc-get-args sexp))))
      (gpt-doc-upcase-arg-list str args-names)
    str))

(defun gpt-doc-fix-arg-case ()
  "Capitalize argument names in documentation."
  (pcase-let* ((`(,_type ,_name ,_str ,beg ,end)
                (gpt-doc-get-current-doc-info))
               (`(,sexp . ,_doc-pos)
                (gpt-doc-get-sexp-with-doc-pos))
               (args-names (mapcar #'symbol-name
                                   (gpt-doc-get-args sexp)))
               (regex
                (when args-names
                  (concat (regexp-opt args-names
                                      'symbols)
                          "\\(\\([^\n]+\\)\\_<\\(\\(\\1\\)\\)\\_>\\)?"))))
    (when (and regex beg)
      (save-excursion
        (goto-char (1+ beg))
        (save-match-data
          (while (re-search-forward
                  regex (1- end) t 1)
            (let ((mbeg (match-beginning 1))
                  (mend (match-end 1))
                  (mbeg-dub (match-beginning 4))
                  (mend-dub (match-end 4)))
              (upcase-region mbeg mend)
              (when (and mbeg-dub mend-dub)
                (downcase-region mbeg-dub mend-dub)))))))))

(defun gpt-doc-fix-whitespace-end ()
  "Remove white space at end of the lines."
  (pcase-let ((`(,_type ,_name ,_str ,beg ,end)
               (gpt-doc-get-current-doc-info)))
    (when (and beg end)
      (save-excursion
        (goto-char (1- end))
        (while (re-search-backward
                "[^ \t\n;]\\([ \t]+\\)$"
                (1+ beg) t 1)
          (replace-match "" nil nil nil 1))))))

(defun gpt-doc-highlight-doc ()
  "Highlight documentation for the thing at point."
  (require 'pulse nil t)
  (when (and (fboundp 'pulse-available-p)
             (pulse-available-p))
    (pcase-let ((`(,_type ,_name ,_str ,beg ,end)
                 (gpt-doc-get-current-doc-info)))
      (when (and beg end (gpt-doc-point-visible beg))
        (pulse-momentary-highlight-region beg end)))))

(defun gpt-doc-active-p ()
  "Check if GPT documentation is active at point."
  (pcase-let ((`(,_type ,_name ,_str ,beg ,end)
               (gpt-doc-get-current-doc-info)))
    (when (and beg end)
      (get-text-property (1+ beg) 'gpt-doc))))

(defun gpt-doc-remove-text-props ()
  "Strip `gpt-doc' text properties from a document region."
  (pcase-let ((`(,_type ,_name ,_str ,beg ,end)
               (gpt-doc-get-current-doc-info)))
    (when (and beg end)
      (remove-text-properties beg end '(gpt-doc t gpt-old-doc t)))))

(defun gpt-doc-restore-text-props ()
  "Restore old text properties after removing `gpt-doc' props."
  (pcase-let* ((`(,sbeg . ,send)
                (gpt-doc-elisp-bounds-of-def-sexp))
               (found
                (when (and sbeg send)
                  (save-excursion
                    (goto-char sbeg)
                    (save-restriction
                      (narrow-to-region sbeg send)
                      (text-property-search-forward
                       'gpt-doc-old)))))
               (beg (and found (prop-match-beginning found)))
               (value (and found
                           (get-text-property beg 'gpt-doc-old))))
    (when (and sbeg send)
      (remove-text-properties sbeg send '(gpt-doc t gpt-old-doc t)))
    (when beg
      (goto-char beg)
      (delete-region beg (gpt-doc-forward-sexp 1))
      (when (stringp value)
        (insert value)))))

(defvar checkdoc-autofix-flag)
(defvar checkdoc-syntax-table)
(defvar checkdoc-bouncy-flag)
(defvar checkdoc-spellcheck-documentation-flag)

(declare-function checkdoc-this-string-valid-engine "checkdoc")
(declare-function checkdoc-defun-info "checkdoc")

(defun gpt-doc-checkdoc-fix ()
  "Fix documentation strings according to `checkdoc' rules."
  (require 'checkdoc)
  (pcase-let ((`(,_type ,_name ,_str ,beg ,end)
               (gpt-doc-get-current-doc-info)))
    (when (and beg end)
      (save-excursion
        (goto-char beg)
        (let ((checkdoc-autofix-flag 'automatic)
              (checkdoc-bouncy-flag nil)
              (checkdoc-spellcheck-documentation-flag nil)
              (beginning-of-defun-function (lambda ()
                                             (pcase-let
                                                 ((`(,start . ,_end)
                                                   (gpt-doc-elisp-bounds-of-def-sexp)))
                                               (when start
                                                 (goto-char start))))))
          (when-let* ((fp (checkdoc-defun-info)))
            (with-syntax-table checkdoc-syntax-table
              (checkdoc-this-string-valid-engine fp))))))))

(defvar gpt-doc-normalize-fns '(gpt-doc-fix-arg-case
                                gpt-doc-escape-doc
                                gpt-doc-fix-symbols-quotes
                                gpt-doc-fix-whitespace-end
                                gpt-doc-refill
                                gpt-doc-checkdoc-fix
                                gpt-doc-refill-list-items)
  "List of functions for normalizing documentation strings.")

(defun gpt-doc-point-visible (pos)
  "Check if position is visible in window.

Argument POS is the buffer position to check for visibility within the window."
  (when-let* ((wnd (get-buffer-window (current-buffer))))
    (with-selected-window wnd
      (< (window-start)
         pos
         (window-end)))))

(defun gpt-doc-run-after-change-hook ()
  "Invoke the `gpt-doc-run-after-change-hook' to run change hooks."
  (pcase-let ((`(,_type ,_name ,_str ,beg ,end)
               (gpt-doc-get-current-doc-info)))
    (when (and beg end)
      (run-hook-with-args 'after-change-functions beg end 0))))

(defun gpt-doc-refill-list-items ()
  "Refill list items in a documentation string."
  (pcase-let ((`(,_type ,_name ,_str ,beg ,end)
               (gpt-doc-get-current-doc-info)))
    (when (and beg end)
      (goto-char end)
      (while (re-search-backward "[.:]\\(\n+\\)-" beg t 1)
        (save-excursion
          (forward-char 1)
          (replace-match "" nil nil nil 1)
          (newline 2)
          (let ((list-start (point)))
            (forward-sentence)
            (fill-region list-start
                         (point))))))))

(defun gpt-doc-refill ()
  "Refill paragraphs in a docstring that exceed 80 characters."
  (pcase-let ((`(,_type ,_name ,_str ,beg ,end)
               (gpt-doc-get-current-doc-info))
              (done))
    (when (and beg end)
      (goto-char (1+ beg))
      (while
          (and (not done)
               (progn (goto-char (line-end-position))
                      (or (nth 3 (syntax-ppss (point)))
                          (when (nth 3 (syntax-ppss (1- (point))))
                            (setq done t)))))
        (when-let* ((start (and (>= (current-column) 80)
                               (save-excursion
                                 (progn
                                   (forward-paragraph -1)
                                   (when (nth 3 (syntax-ppss (point)))
                                     (point)))))))
          (let ((send (save-excursion
                        (forward-paragraph 1)
                        (when (nth 3 (syntax-ppss (point)))
                          (point)))))
            (unless send
              (setq send (ignore-errors (goto-char (nth 8 (syntax-ppss
                                                           (point))))
                                        (when (gpt-doc-forward-sexp
                                               1)
                                          (forward-char -1)
                                          (point)))))
            (goto-char send)
            (fill-region start send)))
        (forward-line 1)))))

;;;###autoload
(defun gpt-doc-post-fix ()
  "Normalize and highlight documentation text."
  (interactive)
  (run-hooks 'gpt-doc-normalize-fns)
  (gpt-doc-highlight-doc)
  (gpt-doc-run-after-change-hook))

(defun gpt-doc-escape-doc-str (str)
  "Escape open parentheses and unescaped single and double quotes in STR."
  (with-temp-buffer
    (insert str)
    (while (re-search-backward
            "[\"]"
            nil t 1)
      (pcase (skip-chars-backward "\\\\")
        (0 (insert "\\"))))
    (buffer-string)))

(defun gpt-doc-escape-doc ()
  "Escape special characters in documentation strings."
  (pcase-let* ((`(,_type ,_name ,_str ,beg ,end)
                (gpt-doc-get-current-doc-info)))
    (when (and beg end)
      (save-excursion
        (goto-char (1- end))
        (while (re-search-backward
                "\\(^[(']\\|\\(\\([']\\)\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)\\([\s)]\\)\\)\\)"
                (1+ beg) t 1)
          (unless (looking-back "[a-z]" 0)
            (if (looking-back "=" 0)
                (forward-char -1)
              (insert "=")
              (forward-char -1))
            (pcase (skip-chars-backward "\\\\")
              (0 (insert "\\\\"))
              (-1 (insert "\\")))))))))

(defun gpt-doc-fix-symbols-quotes ()
  "Replace quotes around symbols with backticks and apostrophes."
  (pcase-let ((`(,_type ,_name ,_str ,beg ,end)
               (gpt-doc-get-current-doc-info)))
    (when (and beg end)
      (save-excursion
        (goto-char (1- end))
        (while (re-search-backward
                "\\(\\(\\([']\\)\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)\\([']\\)\\)\\|\\(\\([`]\\)\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)\\([`]\\)\\)\\)"
                (1+ beg) t 1)
          (let ((full (match-string-no-properties 1))
                (symb (or (match-string-no-properties 4)
                          (match-string-no-properties 8))))
            (if (or (member symb '("t" "nil" "non-nil"))
                    (gpt-doc-upcased-p full))
                (replace-match symb)
              (replace-match (concat "`" symb "'")))))))))

(defun gpt-doc--unqote-response-args (response)
  "Return a modified version of the input string with backquoted symbols unquoted.
Argument RESPONSE is the input string to be modified."
  (with-temp-buffer
    (insert response)
    (goto-char (point-min))
    (while (re-search-forward
            "\\(\\([\"'`]\\)\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)\\([`'\"]\\)\\)"
            nil t
            1)
      (let ((full (match-string-no-properties 1))
            (symb (match-string-no-properties 3)))
        (if (or (member symb '("t" "nil" "non-nil"))
                (gpt-doc-upcased-p full))
            (replace-match symb)
          (replace-match (concat "`" symb "'")))))
    (buffer-string)))

(defun gpt-doc-trim-steps (text)
  "Remove \"Step [0-9]+: Argument\" from the given TEXT.

Argument TEXT is the string input that the function will process to remove
specific patterns."
  (replace-regexp-in-string
   "\\(\\(Step\\[\s]+\\)?[0-9]+[.:][\s\t\r\f\n]*\\)\\(Argument\\|optional argument\\)"
   "" text
   nil nil 1))

(defun gpt-doc-fill-docs (text)
  "Fill the TEXT with formatted sentences, each ending with a period.
Argument TEXT is a string containing the text to be formatted."
  (let ((sentences (split-string text
                                 "\\.\\([\s\t\n\r\f]\\|$\\)" t)))
    (mapconcat
     (lambda (l)
       (setq l (format "%s." l))
       (if (> (length l) 80)
           (with-temp-buffer
             (insert l)
             (fill-region-as-paragraph (point-min)
                                       (point))
             (buffer-string))
         l))
     sentences
     "\n")))

(defun gpt-doc-forward-sexp (count)
  "Return the position after moving forward by COUNT balanced sexps.
Argument COUNT is the number of balanced sexps to move forward."
  (let ((parse-sexp-ignore-comments t))
    (with-syntax-table emacs-lisp-mode-syntax-table
      (let ((pos))
        (while (and (> count 0)
                    (or (not pos)
                        (= pos (point))))
          (setq count (1- count))
          (ignore-errors (forward-sexp 1))
          (setq pos (point)))
        pos))))

(defun gpt-doc-first-list-pos (sexp)
  "Return position of the first proper list in the given SEXP.
Argument SEXP is the s-expression to search for proper lists."
  (and (proper-list-p sexp)
       (seq-position sexp nil (lambda (a &rest _)
                                (proper-list-p a)))))

(defun gpt-doc-remove-doc-string (sexp)
  "Return a modified version of the input SEXP with the doc string removed.
Argument SEXP is the s-expression to remove the doc string from."
  (with-temp-buffer
    (let ((emacs-lisp-mode-hook nil))
      (emacs-lisp-mode)
      (insert (or (ignore-errors (pp-to-string sexp))
                  (prin1-to-string sexp)))
      (goto-char (point-min))
      (gpt-doc--pre-init)
      (buffer-substring-no-properties (point-min)
                                      (point-max)))))

(defun gpt-doc-forward-to-cl-defmethods-args (sexp)
  "Return the position of the first proper list in SEXP plus 2.
Argument SEXP is a list."
  (when-let* ((arg-pos
               (gpt-doc-first-list-pos
                sexp))
              (doc (nth (1+ arg-pos) sexp)))
    (1+ arg-pos)))

(defun gpt-doc-pp-sexp (sexp)
  "Return a formatted string representation of a given s-expression.
Argument SEXP is the s-expression to be formatted."
  (let ((formatted (gpt-doc-remove-doc-string sexp)))
    (pcase (car sexp)
      ((or 'defvar 'defvar-local 'defcustom)
       formatted)
      ((guard (gpt-doc-get-args sexp))
       formatted)
      (_ (with-temp-buffer
           (insert formatted)
           (goto-char (point-min))
           (when (re-search-forward
                  (regexp-opt
                   '("nil")
                   'symbols)
                  nil t 1)
             (replace-match "()"))
           (buffer-string))))))

(defun gpt-doc-get-system-prompt-for-args (sexp)
  "Generate documentation prompt for Emacs Lisp definitions.

Argument SEXP is the symbolic expression to analyze.

Return the final system prompt string with all necessary substitutions made."
  (when-let* ((args
              (or (cdr (assq (car sexp) gpt-doc-special-prompts))
                  (gpt-doc-get-args-names sexp))))
    (let* ((name (format "%s" (cadr sexp)))
           (system (if (stringp args)
                       args
                     gpt-doc-args-prompt))
           (matches (length
                     (gpt-doc-get-matches "%s" system))))
      (if (zerop matches)
          system
        (replace-regexp-in-string "%s" name system)))))

(defun gpt-doc-get-prompt-for-args (sexp &optional related-sexps)
  "Generate user and system prompt for arguments of a given SEXP.

Argument SEXP is a list representing a Lisp expression.

Optional argument RELATED-SEXPS is a list of Lisp expressions related to SEXP."
  (when-let* ((system-prompt
               (gpt-doc-get-system-prompt-for-args sexp))
              (user-prompt (gpt-doc-make-code-prompt
                            sexp
                            related-sexps)))
    (let ((inhibit-message t)
          (message-log-max))
      (and related-sexps
           (message "gpt-doc: sending context %s" (length related-sexps))))
    (cons user-prompt system-prompt)))

(defun gpt-doc-document-arguments (sexp &optional related-sexps)
  "Generate documentation for each argument of a given Emacs Lisp function.

Argument SEXP is a list that represents a symbolic expression.

Optional argument RELATED-SEXPS is a list of symbolic expressions that are
related to SEXP.
It is not required and has no default value."
  (pcase-let*
      ((`(,user-prompt . ,system-prompt)
        (gpt-doc-get-prompt-for-args sexp
                                     related-sexps))
       (text
        (when system-prompt
          (gpt-doc-response-text
           (gpt-doc-gpt-request
            user-prompt
            system-prompt)))))
    (gpt-doc--debug-log
     "gpt-doc-document-arguments raw response text:\n```\n%s\n```\n" text)
    (when text
      (gpt-doc-pipe-ignore-errors
       `(gpt-doc-maybe-read
         ,(apply-partially #'gpt-doc--upcase-args sexp)
         gpt-doc--unqote-response-args
         gpt-doc-trim-steps
         gpt-doc-fill-docs)
       text))))

(defun gpt-doc-pipe-ignore-errors (fns text)
  "Apply a list of functions to a TEXT, ignoring any errors that occur.

pArgument FNS is a list of functions.
Argument TEXT is a string."
  (let ((fn (pop fns)))
    (seq-reduce (lambda (acc fn)
                  (setq acc (or (ignore-errors
                                  (funcall fn acc))
                                acc)))
                fns
                (or (ignore-errors (funcall fn text))
                    text))))

(defun gpt-doc-maybe-read (text)
  "Convert a string TEXT to a Lisp object if it's enclosed in quotes.

Argument TEXT is a string that is checked if it starts and ends with a quotation
mark."
  (if
      (and (string-prefix-p "\"" text)
           (string-suffix-p "\"" text))
      (or (ignore-errors (read text))
          (substring-no-properties text 1 (1- (length text)))
          text)
    text))

(defun gpt-doc-normalize-response-content (text &optional sexp)
  "Normalize and unquote the response content from a GPT request.

Argument TEXT is a string that represents the text to be normalized.

Optional argument SEXP is a boolean value that, if provided, indicates whether
the TEXT should be treated as a symbolic expression (sexp).
The default value is nil."
  (gpt-doc-pipe-ignore-errors
   `(gpt-doc-maybe-read
     ,(apply-partially #'gpt-doc--upcase-args sexp)
     gpt-doc--unqote-response-args)
   text))

(defun gpt-doc-get-matches (re str)
  "Search backwards for matches of a regular expression in a string.

Argument RE is a regular expression string that the function will search for in
the backward direction.

Argument STR is a string where the function will perform the search operation."
  (with-temp-buffer
    (let ((res))
      (insert str)
      (while (re-search-backward re nil t 1)
        (push (match-string-no-properties 0) res))
      res)))

(defun gpt-doc-make-code-prompt (sexp &optional related-sexps)
  "Format code with optional related code.

Argument SEXP is the s-expression to be formatted.

Optional argument RELATED-SEXPS is a list of related s-expressions to be
included in the output."
  (if related-sexps
      (concat (gpt-doc-pp-sexp sexp)
              "\n\n"
              ";; RELATED CODE:\n"
              (gpt-doc-join-sexps related-sexps))
    (gpt-doc-pp-sexp sexp)))

(defun gpt-doc--get-system-prompt-for-summary (sexp)
  "Generate documentation system prompt for the definition SEXP.

Argument SEXP is an S-expression representing an Emacs Lisp definition."
  (let* ((name (cadr sexp))
         (label (format "the %s `%s'"
                        (or (cdr (assq (car sexp) gpt-doc-prompt-types))
                            "definition")
                        name))
         (template
          (pcase (car sexp)
            ((or 'defvar 'defvar-local 'defcustom 'defconst)
             gpt-doc-variable-prompt)
            (_
             gpt-doc-first-sentence-doc-prompt)))
         (matches (length
                   (gpt-doc-get-matches "%s" template))))
    (if (zerop matches)
        template
      (apply #'format template
             (mapcar (lambda (it)
                       (pcase it
                         (0 label)
                         (_ name)))
                     (number-sequence 0 matches))))))

(defun gpt-doc-get-prompt-for-summary (sexp &optional related-sexps)
  "Generate user and system prompt messages for summarizing a given SEXP.

Argument SEXP is a symbolic expression (sexp) in Emacs Lisp.

Optional argument RELATED-SEXPS is a list of related symbolic expressions
\(sexps) in Emacs Lisp."
  (when-let* ((system-prompt (gpt-doc--get-system-prompt-for-summary sexp))
              (user-prompt
               (gpt-doc-make-code-prompt sexp related-sexps)))
    (cons user-prompt system-prompt)))

(defun gpt-doc-get-short-documentation (sexp &optional related-sexps)
  "Generate a short documentation for a given Emacs Lisp function or macro.

Argument SEXP is a symbolic expression (sexp) in Emacs Lisp that the function
will generate documentation for.

Argument RELATED-SEXPS is an optional argument that contains related definitions
that will be joined with the main SEXP for documentation generation."
  (pcase-let* ((`(,user-prompt . ,system-prompt)
                (gpt-doc-get-prompt-for-summary sexp related-sexps))
               (text
                (gpt-doc-response-text (gpt-doc-gpt-request
                                        user-prompt
                                        system-prompt)))
               (normalized (gpt-doc-normalize-response-content
                            text
                            sexp))
               (parts (split-string normalized nil t))
               (first-word (pop parts)))
    (when-let* ((imp (and first-word
                         (boundp 'checkdoc-common-verbs-wrong-voice)
                         (cdr (assoc-string
                               (downcase first-word)
                               checkdoc-common-verbs-wrong-voice)))))
      (setq first-word (capitalize (seq-copy imp))))
    (concat first-word " " (string-join parts " "))))

(defun gpt-doc-document-sexp (sexp &optional related-sexps)
  "Join the first sentence and argument documentation of a SEXP.
Argument SEXP is the sexp (S-expression) that will be documented.
RELATED-SEXPS is additional definitions for context."
  (let* ((first-sentence (gpt-doc-get-short-documentation sexp
                                                          related-sexps))
         (args-docs (gpt-doc-document-arguments sexp
                                                related-sexps)))
    (gpt-doc-quote-args
     (string-join (delq nil (list first-sentence args-docs))
                  "\n\n"))))

(defun gpt-doc-scan-top-level-lists ()
  "Return all Lisp lists at outermost position in current buffer.
An \"outermost position\" means one that it is outside of any syntactic entity:
outside of any parentheses, comments, or strings encountered in the scan."
  (let ((sexps)
        (sexp)
        (vars)
        (defs)
        (imp)
        (feat))
    (goto-char (point-min))
    (while (setq sexp (ignore-errors (read (current-buffer))))
      (pcase sexp
        (`(,(or 'defun 'cl-defun 'defmacro 'cl-defmacro)
           ,(and (pred (symbolp))
             sym
             (guard (not (memq sym '(t nil)))))
           ,(pred (listp))
           . ,_)
         (push sym defs))
        (`(,(or 'defvar 'defvar-local 'defvar-keymap
             'defcustom)
           ,(and (pred (symbolp))
             sym
             (guard (not (memq sym '(t nil)))))
           . ,_)
         (push sym vars))
        (`(require (quote ,(and (pred (symbolp)) sym)) . ,_)
         (push sym imp))
        (`(provide (quote ,(and (pred (symbolp)) sym)) . ,_)
         (push sym feat)))
      (push sexp sexps))
    (nreverse sexps)))

(defun gpt-doc-get-all-buffer-definitions ()
  "Extract all buffer definitions from a given package."
  (let ((sexps)
        (package-name (progn
                        (require 'lisp-mnt)
                        (when (fboundp 'lm-get-package-name)
                          (when-let* ((name (lm-get-package-name)))
                            (file-name-sans-extension name))))))
    (save-excursion
      (goto-char (point-max))
      (while (gpt-doc-move-with #'backward-sexp)
        (when-let* ((sexp (sexp-at-point)))
          (when (and (proper-list-p sexp)
                     (symbolp (cadr sexp))
                     (or (not package-name)
                         (string-prefix-p package-name
                                          (symbol-name (nth 1 sexp)))))
            (push (cons (cadr sexp)
                        sexp)
                  sexps)))))
    sexps))

(defun gpt-doc-unquote-sym (exp)
  "Return the unquoted expression EXP.
Argument EXP is the expression to be unquoted."
  (declare (pure t)
           (side-effect-free t))
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

(defun gpt-doc-flatten-vectors (items)
  "Flatten nested vectors and lists in the given input.

Argument ITEMS is a list or vector that needs to be flattened."
  (setq items (gpt-doc-unquote-sym items))
  (cond ((and items
              (proper-list-p items))
         (mapcar #'gpt-doc-flatten-vectors items))
        ((and items
              (vectorp items))
         (mapcar #'gpt-doc-flatten-vectors (append items nil)))
        (t items)))

(defun gpt-doc--inner-body (sexp)
  "Extract the body from a Lisp definition.

Argument SEXP is an S-expression to be processed by the function."
  (pcase sexp
    (`(,(or 'defun 'cl-defun 'defmacro 'cl-defmacro
         'cl-defmethod 'cl-defsubst 'defsubst
         'transient-define-prefix)
       . ,subbody)
     (pcase subbody
       (`(,(and (pred (symbolp))
            sym
            (guard (not (memq sym '(t nil)))))
          ,(pred (listp))
          . ,body)
        body)))
    (`(,(or 'defcustom 'defvar 'defvar-local 'defvar-keymap 'defconst)
       . ,subbody)
     (pcase subbody
       (`(,(and (pred (symbolp))
            sym
            (guard (not (memq sym '(t nil)))))
          ,body)
        (and body
             (or (listp body)
                 (vectorp body))))))
    (`(,_type ,_name . ,body)
     body)))

(defun gpt-doc-inner-symbols (prefix-name sexp)
  "Return a list of inner symbols in SEXP that match PREFIX-NAME.
PREFIX-NAME is a string used to filter symbols by their name.
SEXP is an Emacs Lisp expression."
  (pcase-let* ((body (gpt-doc--inner-body sexp))
               (inner (flatten-list (gpt-doc-flatten-vectors
                                     body))))
    (seq-filter
     (lambda (it)
       (and (symbolp it)
            (or (not prefix-name)
                (string-prefix-p prefix-name (symbol-name it)))))
     inner)))

(defun gpt-doc-join-sexps (sexps)
  "Join SEXPS into a string with newlines."
  (with-temp-buffer
    (let ((emacs-lisp-mode-hook nil))
      (emacs-lisp-mode)
      (dolist (it (reverse sexps))
        (when-let* ((str (or (ignore-errors (pp-to-string it))
                            (prin1-to-string it))))
          (setq str (replace-regexp-in-string
                     "[(]\\(\\(\\(cl-\\)defmacro\\|defsubst\\|defun\\)[\s\t\n]\\(\\(?:\\w\\|\\s_\\|\\\\.\\)+\\)\\|lambda\\)[\s\t\n]+\\_<\\(nil\\)\\_>"
                     "()"
                     str
                     nil nil 5))
          (save-excursion
            (insert str (if (eobp)
                            ""
                          "\n\n")))
          (pcase-let
              ((`(,_sexp . ,doc-pos)
                (gpt-doc-get-sexp-with-doc-pos)))
            (when doc-pos
              (save-excursion
                (goto-char doc-pos)
                (when (and (looking-at "[\s\t]\"")
                           (not (nth 3 (syntax-ppss))))
                  (delete-char 1)
                  (newline-and-indent))))))))
    (buffer-substring-no-properties (point-min)
                                    (point-max))))

(defun gpt-doc-looks-like-keymapp (sexp)
  "Check if a given s-expression SEXP resembles a keymap definition.

Argument SEXP is a symbolic expression (sexp) that is being checked if it looks
like a keymap."
  (pcase sexp
    (`(defvar ,(and (pred symbolp) _name)
        (let ((,(and (pred symbolp) sym)
               (make-sparse-keymap)))
         . ,(and body (guard (eq sym (car (last body))))
             (guard (seq-every-p (lambda (it)
                                   (memq (car-safe it)
                                    '(set-keymap-parent
                                      define-key lookup-key
                                      make-composed-keymap
                                      when if
                                      unless)))
                     (butlast body)))))
        . ,_rest)
     t)
    (`(defvar-keymap ,(and (pred symbolp) _name)
       . ,rest)
     (let ((body (reverse rest))
           (kalist))
       (while
           (let* ((fn
                   (pop body))
                  (key (pop body)))
             (when (and
                    key
                    fn
                    (stringp key))
               (when (memq (car-safe fn) '(quote function))
                 (setq fn (gpt-doc-unquote-sym fn)))
               (push (cons key fn) kalist))))
       kalist))))

(defun gpt-doc-get-defs-with-sexp-usage (sexp)
  "Extract definitions using SEXP in their body.

Argument SEXP is an S-expression to analyze for definitions and usages."
  (when-let* ((sym (cadr sexp))
              (name (symbol-name sym))
              (re (regexp-opt (list name) 'symbols)))
    (with-syntax-table emacs-lisp-mode-syntax-table
      (let ((sexps))
        (save-excursion
          (goto-char (point-max))
          (while (gpt-doc-move-with #'backward-sexp)
            (save-excursion
              (let ((curr-sexp (sexp-at-point))
                    (end (cdr (bounds-of-thing-at-point 'sexp)))
                    (found))
                (when (and curr-sexp
                           (proper-list-p curr-sexp)
                           (not (equal curr-sexp sexp))
                           (symbolp (cadr curr-sexp)))
                  (while (and (not found)
                              (re-search-forward re end t 1))
                    (setq found (not (nth 4 (syntax-ppss (point))))))
                  (when found (push curr-sexp sexps)))))))
        sexps))))

(defun gpt-doc-get-related-defs (sexp)
  "Extract related definitions from a given `S-expression'.

Argument SEXP is a symbolic expression (sexp) in Emacs Lisp."
  (pcase-let*
      ((package-name (progn
                       (require 'lisp-mnt)
                       (when (fboundp 'lm-get-package-name)
                         (when-let* ((name (lm-get-package-name)))
                           (file-name-sans-extension name)))))
       (all-defs (gpt-doc-get-all-buffer-definitions))
       (filtered-defs (seq-remove (pcase-lambda (`(,_n . ,item))
                                    (or
                                     (not
                                      (memq (car-safe item)
                                            '(defvar defun cl-defun defcustom
                                               defmacro defcustom defclass
                                               cl-defmethod)))
                                     (gpt-doc-looks-like-keymapp item)))
                                  all-defs)))
    (let* ((name)
           (initial-items (delete-dups
                           (delq nil (gpt-doc-inner-symbols package-name sexp))))
           (items (seq-copy initial-items))
           (processed-syms)
           (related-defs))
      (while (setq name (pop items))
        (unless (memq name processed-syms)
          (let* ((def (cdr (assq name filtered-defs)))
                 (new-syms (delete-dups (delq nil (gpt-doc-inner-symbols
                                                   package-name def)))))
            (when new-syms
              (setq items (delq nil (append items new-syms))))
            (unless (or (not def)
                        (memq def related-defs))
              (push def related-defs)))
          (push name processed-syms)))
      (seq-sort-by (lambda (it)
                     (if (memq (cadr it) initial-items)
                         -1
                       (let* ((full-def (assq (nth 1 it) filtered-defs))
                              (pos (seq-position filtered-defs full-def 'eq)))
                         (or pos 0))))
                   #'< (nreverse related-defs)))))

(defun gpt-doc-get-shallow-related-defs (sexp)
  "Extract related definitions from a given package and SEXP.

Parses the given SEXP and returns a list of related definitions.
The SEXP is parsed to extract symbols that are related to the package
name. The related definitions are then returned as a list, sorted by
their position in the original list of all definitions."
  (pcase-let*
      ((package-name (progn
                       (require 'lisp-mnt)
                       (when (fboundp 'lm-get-package-name)
                         (when-let* ((name (lm-get-package-name)))
                           (file-name-sans-extension name)))))
       (all-defs (gpt-doc-get-all-buffer-definitions))
       (filtered-defs (seq-remove (pcase-lambda (`(,_n . ,item))
                                    (or
                                     (not
                                      (memq (car-safe item)
                                            '(defvar-local defvar defun cl-defun
                                              defmacro defcustom)))
                                     (gpt-doc-looks-like-keymapp item)))
                                  all-defs)))
    (let ((name)
          (items (delete-dups
                  (delq nil (gpt-doc-inner-symbols package-name sexp))))
          (processed-syms)
          (related-defs))
      (while (setq name (pop items))
        (unless (memq name processed-syms)
          (let* ((def (cdr (assq name filtered-defs))))
            (unless (or (not def)
                        (memq def related-defs))
              (push def related-defs)))
          (push name processed-syms)))
      (seq-sort-by (lambda (it)
                     (let* ((full-def (assq (nth 1 it) filtered-defs))
                            (pos (seq-position filtered-defs full-def 'eq)))
                       (or pos 0)))
                   #'< related-defs))))

(defun gpt-doc-get-related-definitions (sexp strategy)
  "Retrieve related definitions based on the given S-expression and strategy.

Argument SEXP is the s-expression to find related definitions for.

Argument STRATEGY is an integer or boolean that determines the method used to
find related definitions."
  (if (eq strategy t)
      (mapcar #'cdr (gpt-doc-get-all-buffer-definitions))
    (when-let* ((fn
                (pcase strategy
                  (4 #'gpt-doc-get-shallow-related-defs)
                  (16 #'gpt-doc-get-related-defs))))
      (if
          (eq 'defcustom (car sexp))
          (append (gpt-doc-get-defs-with-sexp-usage sexp)
                  (funcall
                   fn
                   sexp))
        (funcall
         fn
         sexp)))))

;;;###autoload
(defun gpt-doc-show-related-defs (&optional all)
  "Display related definitions for an Emacs Lisp expression.

Optional argument ALL determines whether to include all related definitions or
just shallow ones.

If non-nil, ALL related definitions are included; otherwise,
only shallow related definitions are included."
  (interactive "P")
  (let* ((sexp (car (gpt-doc-get-sexp-with-doc-pos)))
         (related-sexps (gpt-doc-get-related-definitions
                         sexp
                         (if all 16 4)))
         (str (gpt-doc-make-code-prompt sexp related-sexps)))
    (if (not related-sexps)
        (message "No related sexps found")
      (gpt-doc-show-in-popup
       nil
       "*gpt-doc-related-definitions*"
       'display-buffer-in-direction
       (lambda ()
         (let ((emacs-lisp-mode-hook nil))
           (emacs-lisp-mode)
           (insert str)
           (while (and (gpt-doc-move-with #'backward-sexp)
                       (looking-at "[(]"))
             (save-excursion
               (pcase-let* ((`(,item . ,arg-end)
                             (gpt-doc-get-sexp-with-doc-pos))
                            (`(,_type ,_name ,_old-doc ,beg ,end)
                             (gpt-doc-get-current-doc-info)))
                 (goto-char end)
                 (while (re-search-backward "[\\]n" beg t 1)
                   (replace-match "\n"))
                 (goto-char arg-end)
                 (when (and (looking-back "\\_<\\(nil\\)\\_>" 0)
                            (memq (car-safe item)
                                  (list 'defsubst 'defmacro 'defun 'cl-defun
                                        'cl-defmacro
                                        'transient-define-suffix
                                        'transient-define-prefix
                                        'transient-define-argument
                                        'transient-define-infix)))
                   (skip-chars-backward "a-z")
                   (delete-region (point) arg-end)
                   (insert "()")))))))))))

(defun gpt-doc-show-in-popup (str &optional buff-name action setup-fn)
  "Display string or result in a popup buffer.

Argument STR is the string or a function to be displayed in the popup buffer.

Optional argument BUFF-NAME is the name of the buffer to be used for the popup;
defaults to \"*gpt-doc*\".

Optional argument ACTION is a cons cell or a symbol that determines the display
ACTION for the popup buffer.

Optional argument SETUP-FN is a function to be called for additional setup after
the popup buffer is created."
  (let ((buffer (get-buffer-create (or buff-name "*gpt-doc*"))))
    (with-current-buffer buffer
      (with-current-buffer-window
          buffer
          (if (consp action)
              action
            (cons (or action 'display-buffer-in-direction)
                  '((window-height . fit-window-to-buffer)
                    (preserve-size . window-preserve-size))))
          (lambda (window _value)
            (with-selected-window window
              (setq buffer-read-only t)
              (let ((inhibit-read-only t))
                (when-let* ((quit-key (where-is-internal
                                       'quit-window
                                       special-mode-map
                                       t t t))
                            (map (make-sparse-keymap)))
                  (define-key map quit-key #'quit-window)
                  (use-local-map (make-composed-keymap
                                  map
                                  (current-local-map))))
                (when setup-fn
                  (funcall setup-fn))
                (when str
                  (if (functionp str)
                      (funcall str)
                    (save-excursion
                      (insert str))))))
            (select-window window))))))

(defun gpt-doc-get-curr-sexp-start ()
  "Find the start position of the current sexp."
  (pcase-let
      ((`(,beg . ,_end)
        (gpt-doc-elisp-bounds-of-def-sexp)))
    beg))

(defun gpt-doc-get-sexp-as-string ()
  "Return the string representation of the nearest parent definition."
  (pcase-let
      ((`(,beg . ,end)
        (gpt-doc-elisp-bounds-of-def-sexp)))
    (when (and beg end)
      (buffer-substring-no-properties beg end))))

(defun gpt-doc-get-sexp-with-doc-pos ()
  "Extracts the sexp and its documentation position from the current function."
  (pcase-let
      ((`(,beg . ,_end)
        (gpt-doc-elisp-bounds-of-def-sexp))
       (doc-pos))
    (when beg
      (save-excursion
        (goto-char beg)
        (let ((sexp (sexp-at-point)))
          (when (gpt-doc-move-with #'down-list 1)
            (let ((count (cdr (assq (car sexp)
                                    gpt-doc-docstring-positions))))
              (when (functionp count)
                (setq count (funcall count sexp)))
              (when count
                (gpt-doc-forward-sexp count)
                (setq doc-pos (point)))))
          (and sexp doc-pos (cons sexp doc-pos)))))))

(defun gpt-doc-fetch-models ()
  "Fetch and sort GPT models by creation time from OpenAI API."
  (let* ((url-request-method "GET")
         (url-request-extra-headers
          `(("Content-Type" . "application/json")
            ("Authorization" . ,(format "Bearer %s"
                                 (gpt-doc-get-api-key)))))
         (buffer (url-retrieve-synchronously
                  "https://api.openai.com/v1/models" nil 'silent))
         (response (gpt-doc--json-parse-string
                    (with-current-buffer buffer
                      (buffer-substring-no-properties
                       url-http-end-of-headers (point-max)))
                    nil 'list)))
    (nreverse (seq-sort-by
               (lambda (it)
                 (seconds-to-time (alist-get 'created it)))
               #'time-less-p
               (cdr (assq 'data response))))))

(defun gpt-doc-format-time-diff (time)
  "Calculate and format the TIME difference from the current time.

Argument TIME is the time value that will be compared with the current time to
calculate the time difference."
  (let ((diff-secs (- (float-time (current-time))
                      (float-time time))))
    (pcase-let ((`(,format-str . ,value)
                 (cond ((< diff-secs 60)
                        (cons "%d second" (truncate diff-secs)))
                       ((< diff-secs 3600)
                        (cons "%d minute" (truncate (/ diff-secs 60))))
                       ((< diff-secs 86400)
                        (cons "%d hour" (truncate (/ diff-secs 3600))))
                       ((< diff-secs 2592000)
                        (cons "%d day" (truncate (/ diff-secs 86400))))
                       (t
                        (cons "%d month" (truncate (/ diff-secs 2592000)))))))
      (format (concat format-str (if (= value 1) " ago" "s ago")) value))))

;;;###autoload
(defun gpt-doc-change-model (model)
  "Change the default GPT MODEL used by OpenAI API.

Argument MODEL is a string representing the API model for OpenAI."
  (interactive (list (gpt-doc-read-model)))
  (if (yes-or-no-p "Save model?")
      (customize-save-variable 'gpt-doc-gpt-model
                               model
                               "gpt-doc")
    (setq-default gpt-doc-gpt-model model)))

(defun gpt-doc-read-model ()
  "Fetch and select a GPT model based on creation time."
  (let* ((models (gpt-doc-fetch-models))
         (alist (mapcar (lambda (it)
                          (cons (alist-get 'id it)
                                it))
                        models))
         (annotf (lambda (str)
                   (when-let* ((data (cdr (assoc str alist))))
                     (concat
                      "  "
                      (string-join (delq nil (list
                                              (gpt-doc-format-time-diff
                                               (time-to-seconds (alist-get
                                                                 'created
                                                                 data)))))
                                   " ")
                      " "))))
         (display-sort-fn (lambda (items)
                            (reverse (seq-sort-by (lambda (str)
                                                    (let ((data
                                                           (cdr
                                                            (assoc str
                                                                   alist))))
                                                      (seconds-to-time
                                                       (alist-get
                                                        'created
                                                        data))))
                                                  #'time-less-p items)))))
    (completing-read "Model: "
                     (lambda (str pred action)
                       (if (eq action 'metadata)
                           `(metadata
                             (annotation-function . ,annotf)
                             (display-sort-function . ,display-sort-fn))
                         (complete-with-action action alist str pred))))))

(defun gpt-doc-flymake-duplicate-docstrings-in-file (&optional file)
  "Detect and print duplicate docstrings in a FILE.

If FILE is not provided, the current buffer's FILE is used."
  (interactive (list buffer-file-name))
  (let* ((file (or file
                   (car command-line-args-left)))
         (result)
         (dups))
    (with-temp-buffer
      (insert-file-contents file)
      (let ((emacs-lisp-mode-hook nil))
        (emacs-lisp-mode)
        (goto-char (point-max))
        (while (and (gpt-doc-move-with #'backward-sexp)
                    (looking-at "[(]"))
          (pcase-let* ((doc (gpt-doc-get-current-doc-info))
                       (`(,_type ,_name ,doc-str ,beg ,end)
                        doc))
            (when doc
              (pcase-let ((`(,_type ,_dname ,_ ,dup-beg ,dup-end)
                           (and doc-str
                                (seq-find
                                 (pcase-lambda
                                   (`(,_k ,_n ,str . _rest))
                                   (and str (string= str doc-str)))
                                 result))))
                (when (and dup-beg dup-end)
                  (let ((diag-a
                         (list dup-beg dup-end :note "Duplicated docstring"))
                        (diag-b
                         (list beg end :note "Duplicated docstring")))
                    (push diag-a dups)
                    (push diag-b dups))))
              (push doc result))))))
    (prin1 :gpt-doc-flymake-output-start)
    (terpri)
    (pp dups)))

(defvar-local gpt-doc--flymake-process nil
  "Buffer-local process started for checking duplicate docstrings in the buffer.")

(defun gpt-doc-flymake-report-duplicate-docstrings (&optional report-fn &rest
                                                              _args)
  "Detect and report duplicate docstrings.

Optional argument REPORT-FN is a function to call with the list of duplicate
docstring diagnostics."
  (when gpt-doc--flymake-process
    (when (process-live-p gpt-doc--flymake-process)
      (kill-process gpt-doc--flymake-process)))
  (let ((temp-file (make-temp-file "gpt-doc-flymake-check-dups"))
        (source-buffer (current-buffer))
        (coding-system-for-write 'utf-8-unix)
        (coding-system-for-read 'utf-8))
    (save-restriction
      (widen)
      (write-region (point-min)
                    (point-max) temp-file nil 'nomessage))
    (let*
        ((output-buffer (generate-new-buffer " *gpt-doc-flymake-check-dups*")))
      (setq gpt-doc--flymake-process
            (make-process
             :name "gpt-doc-flymake-check-dups"
             :buffer output-buffer
             :command `(,(expand-file-name invocation-name invocation-directory)
                        "-Q"
                        "--batch"
                        ;; "--eval" "(setq load-prefer-newer t)"
                        "-l" ,gpt-doc-load-filename
                        "-f" "gpt-doc-flymake-duplicate-docstrings-in-file"
                        ,temp-file)
             :connection-type 'pipe
             :sentinel
             (lambda (proc _event)
               (unless (process-live-p proc)
                 (unwind-protect
                     (cond
                      ((not (and (buffer-live-p source-buffer)
                                 (eq proc (with-current-buffer source-buffer
                                            gpt-doc--flymake-process))))
                       (flymake-log :warning
                                    "gpt-doc process %s obsolete" proc))
                      ((zerop (process-exit-status proc))
                       (let* ((data (with-current-buffer output-buffer
                                      (goto-char (point-min))
                                      (search-forward ":gpt-doc-flymake-output-start")
                                      (read (point-marker))))
                              (result (mapcar (lambda (it)
                                                (apply #'flymake-make-diagnostic
                                                       source-buffer
                                                       it))
                                              data)))
                         (if report-fn
                             (funcall report-fn result)
                           (message "gpt-doc %s" result)
                           nil)))
                      (t
                       (if report-fn
                           (funcall report-fn
                                    :panic
                                    :explanation
                                    (format "gpt-doc process %s died" proc))
                         (message (format "gpt-doc process %s died" proc)))))
                   (ignore-errors (delete-file temp-file))
                   (kill-buffer output-buffer))))
             :stderr " *stderr of gpt-doc-flymake-check-dups*"
             :noquery t)))))

(defun gpt-doc-flymake-init ()
  "Initialize GPT-doc Flymake for duplicate docstring checking."
  (add-hook 'flymake-diagnostic-functions
            #'gpt-doc-flymake-report-duplicate-docstrings
            nil
            t))

;;;###autoload
(defun gpt-doc-flymake-start ()
  "Check whole buffer for duplicated documentation strings.
Add `gpt-doc-flymake-report-duplicate-docstrings' to flymake diagnostic and run
flymake."
  (interactive)
  (require 'flymake)
  (gpt-doc-flymake-init)
  (when (fboundp 'flymake-start)
    (flymake-start)))

(defun gpt-doc-collect-doc-dups ()
  "Collect duplicate documentation strings from a given buffer."
  (let ((alist))
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-max))
        (while (and (gpt-doc-move-with #'backward-sexp)
                    (looking-at "[(]"))
          (pcase-let* ((doc (gpt-doc-get-current-doc-info))
                       (`(,_type ,_name ,doc-str ,beg ,_end)
                        doc))
            (when (and doc doc-str beg
                       (not (get-text-property (1+ beg) 'gpt-doc)))
              (if-let* ((cell (assoc-string doc-str alist)))
                  (setcdr cell (append (cdr cell)
                                       (list doc)))
                (let ((cell (cons doc-str (list doc))))
                  (push cell alist))))))))
    (seq-filter (pcase-lambda (`(,_k . ,v))
                  (> (length v) 1))
                alist)))

(defun gpt-doc-jump-to-definition (doc-info)
  "Jump to the definition of a given document in the buffer.

Argument DOC-INFO is a list that contains information about the documentation."
  (pcase-let ((`(,type ,name ,_doc ,_end)
               doc-info)
              (found))
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-max))
        (while (and (not found)
                    (gpt-doc-move-with #'backward-sexp)
                    (looking-at "[(]"))
          (pcase-let ((`(,item-type ,n ,_doc ,_end)
                       (gpt-doc-get-current-doc-info)))
            (when (and (eq n name)
                       (eq item-type type))
              (setq found (point)))))))
    (when found
      (gpt-doc-goto-char found))
    found))

(defun gpt-doc-get-current-doc-info ()
  "Retrieve info about the current element to document."
  (pcase-let
      ((`(,sexp . ,doc-pos)
        (gpt-doc-get-sexp-with-doc-pos)))
    (when doc-pos
      (save-excursion
        (goto-char doc-pos)
        (while
            (when (skip-chars-forward "\s\t\n\r\f")
              (looking-at comment-start))
          (forward-comment 1))
        (append (list (car sexp)
                      (cadr sexp))
                (when (looking-at "\"")
                  (let* ((start (point))
                         (end (progn (forward-sexp)
                                     (point)))
                         (curr (buffer-substring-no-properties start
                                                               end)))
                    (list curr
                          start
                          end
                          (gpt-doc-get-sexp-as-string)))))))))

(defun gpt-doc-curr-sexp-documented-p ()
  "Check if current s-expression has a docstring."
  (pcase-let ((`(,item-type ,_n ,doc ,_end)
               (gpt-doc-get-current-doc-info)))
    (and item-type (stringp doc))))

(defun gpt-doc--stream-insert-response (response info)
  "Insert and format RESPONSE text at a marker.

Argument RESPONSE is a string containing the server's response.

Argument INFO is a property list containing the insertion position and tracking
information."
  (let ((start-marker (plist-get info :position))
        (tracking-marker (plist-get info :tracking-marker))
        (inhibit-modification-hooks t))
    (when response
      (with-current-buffer (marker-buffer start-marker)
        (save-excursion
          (unless tracking-marker
            (goto-char start-marker)
            (setq tracking-marker (set-marker (make-marker) (point)))
            (set-marker-insertion-type tracking-marker t)
            (plist-put info :tracking-marker tracking-marker))
          (put-text-property 0 (length response) 'gpt-doc 'response
                             response)
          (goto-char tracking-marker)
          (gpt-doc-insert-with-fill (gpt-doc-escape-doc-str response)))))))

(defun gpt-doc-insert-with-fill (response)
  "Insert text and format as a paragraph.

Argument RESPONSE is a string to be inserted and potentially filled within the
buffer."
  (let* ((line-beg (line-beginning-position))
         (first-sentence-start (save-excursion
                                 (goto-char line-beg)
                                 (when (looking-at "[\s\t]*\"")
                                   (re-search-forward "[\s\t]*\"" nil t 1))))
         (beg
          (or first-sentence-start line-beg))
         (pos (point))
         (chunk
          (cond ((and (= beg pos)
                      (string-prefix-p "(" response))
                 (concat "\\" response))
                (t response)))
         (curr-content
          (buffer-substring-no-properties beg (point)))
         (wid (string-width (concat
                             curr-content
                             chunk))))
    (cond ((and (string-prefix-p "\n" chunk)
                (or (string-suffix-p " " curr-content)
                    (string-suffix-p "\t" curr-content)))
           (delete-char (save-excursion
                          (skip-chars-backward "\s\t")))
           (insert chunk))
          ((or
            first-sentence-start
            (<= wid 80)
            (string-prefix-p "\n" chunk))
           (insert chunk))
          ((string-suffix-p " " curr-content)
           (delete-char (save-excursion
                          (skip-chars-backward " ")))
           (insert "\n" chunk))
          ((string-prefix-p " " chunk)
           (delete-char (save-excursion
                          (skip-chars-backward " ")))
           (insert "\n" (string-trim-left chunk)))
          (t (insert chunk)))))

(defun gpt-doc-abort-url-retrieve (url-buff)
  "Cancel ongoing URL fetch and close buffer.

Argument URL-BUFF is the buffer associated with the URL retrieval process to be
aborted."
  (pcase-dolist (`(,req-buff . ,marker) gpt-doc--request-url-buffers)
    (when (or (eq url-buff t)
              (eq req-buff url-buff))
      (when (buffer-live-p req-buff)
        (let ((proc (get-buffer-process req-buff)))
          (when proc
            (delete-process proc))
          (kill-buffer req-buff))))
    (gpt-doc-restore-abort-marker marker))
  (setq gpt-doc--request-url-buffers
        (if (eq url-buff t)
            nil
          (assq-delete-all url-buff gpt-doc--request-url-buffers)))
  (when (symbol-value 'gpt-doc-mode)
    (gpt-doc-mode -1)))

(defun gpt-doc-restore-abort-marker (marker)
  "Restore text properties and clean up after aborting a request.

Argument MARKER is a marker object indicating the position in the buffer where
the text properties should be restored."
  (let ((buff
         (when (markerp marker)
           (marker-buffer marker))))
    (when (buffer-live-p buff)
      (with-current-buffer buff
        (save-excursion
          (gpt-doc-goto-char marker)
          (gpt-doc-restore-text-props))))
    (when-let* ((cell (rassq marker gpt-doc--request-url-buffers)))
      (setcdr cell nil))))

(defun gpt-doc--abort-all ()
  "Cancel all pending GPT document requests."
  (gpt-doc-abort-url-retrieve t))

(defun gpt-doc-abort-buffer (buffer)
  "Cancel ongoing URL request for buffer.

Argument BUFFER is the buffer associated with a GPT-DOC request to be aborted."
  (pcase-dolist (`(,req-buff . ,marker) gpt-doc--request-url-buffers)
    (let ((buff
           (when (markerp marker)
             (marker-buffer marker))))
      (when (eq buffer buff)
        (gpt-doc-abort-url-retrieve req-buff)))))

(defun gpt-doc-abort-current-buffer ()
  "Cancel processing in the active buffer."
  (let ((buff (current-buffer)))
    (gpt-doc-abort-buffer buff)))

(defun gpt-doc-encode-json (data)
  "Convert DATA to JSON and encode in UTF-8.

Argument DATA is the object to be encoded as a JSON string."
  (encode-coding-string
   (json-encode
    data)
   'utf-8))

(defun gpt-doc-stream-get-content (response)
  "Retrieve and decode content from a RESPONSE object.

Argument RESPONSE is a plist containing the API response data."
  (when-let* ((choices (plist-get response
                                  :choices))
              (choice (elt choices 0))
              (delta (plist-get choice :delta))
              (content (plist-get delta :content)))
    (decode-coding-string content 'utf-8)))

(defvar gpt-doc--debug-data-raw nil
  "Stores raw data for debugging purposes.")

(defun gpt-doc-refontify-region (start end)
  "Trigger refontification from START to END."
  (font-lock-flush start end)
  (font-lock-ensure start end))

(defun gpt-doc-after-change-hook (info)
  "Parse and insert GPT-generated Emacs Lisp documentation.

Argument INFO is a property list containing various request-related data."
  (let ((request-buffer (plist-get info :request-buffer))
        (request-marker (plist-get info :request-marker))
        (buffer (plist-get info :buffer))
        (callback (plist-get info :callback)))
    (when request-buffer
      (with-current-buffer request-buffer
        (when (and (boundp 'url-http-end-of-headers)
                   url-http-end-of-headers)
          (save-match-data
            (save-excursion
              (if request-marker
                  (goto-char request-marker)
                (goto-char url-http-end-of-headers)
                (setq request-marker (point-marker))
                (plist-put info :request-marker request-marker))
              (unless (eolp)
                (beginning-of-line))
              (let ((errored nil))
                (when gpt-doc-debug
                  (setq gpt-doc--debug-data-raw
                        (append gpt-doc--debug-data-raw
                                (list
                                 (list
                                  (buffer-substring-no-properties
                                   (point-min)
                                   (point-max))
                                  (point))))))
                (while (and (not errored)
                            (search-forward "data: " nil t))
                  (let* ((line
                          (buffer-substring-no-properties
                           (point)
                           (line-end-position))))
                    (if (string= line "[DONE]")
                        (progn
                          (when (and (not (plist-get info :done))
                                     (buffer-live-p buffer))
                            (plist-put info :done t)
                            (let ((tracking-marker
                                   (plist-get info
                                              :tracking-marker))
                                  (final-callback
                                   (plist-get info
                                              :final-callback))
                                  (start-marker
                                   (plist-get info
                                              :position)))
                              (with-current-buffer buffer
                                (let* ((beg
                                        (when start-marker
                                          (marker-position start-marker)))
                                       (end
                                        (when tracking-marker
                                          (marker-position tracking-marker))))
                                  (save-excursion
                                    (gpt-doc-refontify-region beg end)
                                    (when tracking-marker
                                      (goto-char tracking-marker))
                                    (when final-callback
                                      (funcall
                                       final-callback))
                                    (when start-marker
                                      (goto-char start-marker))
                                    (gpt-doc-remove-text-props))
                                  (setq gpt-doc--request-url-buffers
                                        (assq-delete-all
                                         (plist-get info :request-buffer)
                                         gpt-doc--request-url-buffers)))
                                (when (symbol-value 'gpt-doc-mode)
                                  (gpt-doc-mode -1)))))
                          (set-marker
                           request-marker
                           (point)))
                      (condition-case _err
                          (let* ((data (gpt-doc--json-parse-string
                                        line 'plist))
                                 (err (plist-get data :error)))
                            (end-of-line)
                            (set-marker
                             request-marker
                             (point))
                            (if err
                                (progn
                                  (setq errored t)
                                  (when err
                                    (message "gpt-doc-error: %s"
                                             (or
                                              (plist-get err
                                                         :message)
                                              err))))
                              (when callback
                                (funcall
                                 callback
                                 data))))
                        (error
                         (setq errored t)
                         (goto-char
                          request-marker))))))))))))))

(defun gpt-doc-retrieve-error (status)
  "Extract and format error details from STATUS.

Argument STATUS is a plist containing the status of the HTTP request."
  (pcase-let*
      ((status-error (plist-get status :error))
       (`(_err ,type ,code) status-error)
       (description
        (and status-error
             (progn
               (when (and (boundp
                           'url-http-end-of-headers)
                          url-http-end-of-headers)
                 (goto-char url-http-end-of-headers))
               (when-let* ((err (ignore-errors
                                 (cdr-safe
                                  (assq 'error
                                        (gpt-doc-json--read-buffer
                                         'alist))))))
                 (or (cdr-safe (assq 'message err)) err))))))
    (when status-error
      (let* ((prefix (if (facep 'error)
                         (propertize
                          "gpt-doc error"
                          'face
                          'error)
                       "gpt-doc error"))
             (details (delq nil
                            (list
                             (when type  (format "%s request failed" type))
                             (when code (format "with status %s" code))
                             (when description (format "- %s" description))))))
        (if details
            (concat prefix ": "
                    (string-join
                     details
                     " "))
          prefix)))))

(defun gpt-doc-show-error (text)
  "Display error message TEXT in a popup buffer.

Argument TEXT is a string to be displayed in the error popup buffer."
  (gpt-doc-show-in-popup text
                         "*gpt-doc-error*"
                         nil
                         (lambda ()
                           (when (fboundp 'visual-line-mode)
                             (visual-line-mode 1)))))

(defvar-local gpt-doc--bus nil)
(defun gpt-doc--abort-read-key ()
  "Abort `read-key' sequence after a set number of `keyboard-quit' presses."
  (let ((last-key)
        (len 0))
    (while (and len (< len gpt-doc-abort-on-keyboard-quit-count)
                (setq last-key
                      (read-key-sequence-vector "")))
      (unwind-protect
          (setq last-key
                (read-key-sequence-vector ""))
        (if (member last-key
                    (where-is-internal 'keyboard-quit nil nil t t))
            (message
             (substitute-command-keys
              "gpt-doc: Press `\\[keyboard-quit]' %d more times to force interruption.")
             (- gpt-doc-abort-on-keyboard-quit-count len))
          (setq unread-command-events
                (append last-key
                        unread-command-events))
          nil))
      (setq len (1+ len)))
    last-key))
(defun gpt-doc-command-watcher ()
  "Monitor `keyboard-quit' commands and handle GPT documentation aborts."
  (cond ((and gpt-doc--request-url-buffers
              (eq this-command 'keyboard-quit))
         (push this-command gpt-doc--bus)
         (let ((len (length gpt-doc--bus)))
           (cond ((>= len gpt-doc-abort-on-keyboard-quit-count)
                  (message nil)
                  (minibuffer-message  "gpt-doc: Aborting")
                  (setq gpt-doc--bus nil)
                  (gpt-doc-abort-all))
                 ((< len gpt-doc-abort-on-keyboard-quit-count)
                  (message nil)
                  (minibuffer-message
                   (substitute-command-keys
                    "gpt-doc: Press `\\[keyboard-quit]' %d more times to force interruption.")
                   (- gpt-doc-abort-on-keyboard-quit-count len))))))
        (gpt-doc--bus (setq gpt-doc--bus nil))))

;;;###autoload
(define-minor-mode gpt-doc-mode
  "Toggle monitoring `keyboard-quit' commands for aborting GPT requests.

Enable `gpt-doc-mode' to monitor and handle `keyboard-quit' commands for
aborting GPT documentation requests.

When active, pressing `\\[keyboard-quit]' multiple times can trigger the
cancellation of ongoing documentation generation processes.

See also custom variable `gpt-doc-abort-on-keyboard-quit-count' for exact
number of `keyboard-quit' presses to abort."
  :lighter " gpt-doc"
  :global nil
  (if gpt-doc-mode
      (add-hook 'post-command-hook #'gpt-doc-command-watcher nil 'local)
    (remove-hook 'post-command-hook #'gpt-doc-command-watcher 'local)
    (setq gpt-doc--bus nil)))

(defun gpt-doc-stream-request (user-prompt system-prompt &optional
                                           final-callback buffer position)
  "Send GPT stream request with USER-PROMPT and SYSTEM-PROMPT.

Argument SYSTEM-PROMPT is a string representing the system's part of the
conversation.

Argument USER-PROMPT is a string representing the user's part of the
conversation.

Optional argument FINAL-CALLBACK is a function to be called when the request is
completed.

Optional argument BUFFER is the buffer where the output should be inserted. It
defaults to the current buffer.

Optional argument POSITION is the position in the BUFFER where the output should
be inserted. It can be a marker, an integer, or nil. If nil, the current point
or region end is used."
  (let* ((buffer (or buffer (current-buffer)))
         (start-marker
          (cond ((not position)
                 (point-marker))
                ((markerp position) position)
                ((integerp position)
                 (set-marker (make-marker) position buffer))))
         (info (list
                :buffer buffer
                :final-callback final-callback
                :position start-marker))
         (url-request-extra-headers `(("Authorization" .
                                       ,(encode-coding-string
                                         (string-join
                                          `("Bearer"
                                            ,(gpt-doc-get-api-key))
                                          " ")
                                         'utf-8))
                                      ("Content-Type" . "application/json")))
         (url-request-method "POST")
         (url-request-data (gpt-doc-encode-json
                            (list
                             :messages
                             (apply #'vector `((:role "system"
                                                :content ,system-prompt)
                                               (:role "user"
                                                :content ,user-prompt)))
                             :model gpt-doc-gpt-model
                             :temperature gpt-doc-gpt-temperature
                             :stream t)))
         (request-buffer)
         (callback
          (lambda (response)
            (let ((err (plist-get response :error)))
              (if err
                  (progn
                    (message "gpt-doc-callback error: %s"
                             (or
                              (plist-get err
                                         :message)
                              err))
                    (when (buffer-live-p buffer)
                      (let ((start-marker
                             (plist-get info
                                        :position)))
                        (gpt-doc-restore-abort-marker start-marker))))
                (when (buffer-live-p buffer)
                  (with-current-buffer buffer
                    (gpt-doc--stream-insert-response
                     (gpt-doc-stream-get-content
                      response)
                     info))))))))
    (plist-put info :callback callback)
    (setq request-buffer
          (url-retrieve
           gpt-doc-gpt-url
           (lambda (status &rest _events)
             (let* ((buff (current-buffer))
                    (err
                     (gpt-doc-retrieve-error status)))
               (if (not err)
                   (when (symbol-value 'gpt-doc-mode)
                     (gpt-doc-mode -1))
                 (run-with-timer 0.5 nil #'gpt-doc-abort-url-retrieve buff)
                 (message err))))))
    (plist-put info :request-buffer request-buffer)
    (push (cons request-buffer start-marker) gpt-doc--request-url-buffers)
    (with-current-buffer buffer
      (add-hook 'kill-buffer-hook #'gpt-doc-abort-current-buffer nil t))
    (with-current-buffer request-buffer
      (add-hook 'after-change-functions
                (lambda (&rest _)
                  (gpt-doc-after-change-hook info))
                nil t))))

(defun gpt-doc-arg-system-prompt (arg-user-prompt arg-system-prompt &optional
                                                  callback)
  "Insert and format GPT-generated Emacs Lisp documentation.

Argument ARG-USER-PROMPT is the user's part of the conversation as a string.

Argument ARG-SYSTEM-PROMPT is the system's part of the conversation as a string.

Optional argument CALLBACK is a function to be called when the documentation
process is completed."
  (save-excursion
    (insert "\n\n")
    (gpt-doc-stream-request arg-user-prompt
                            arg-system-prompt
                            (lambda ()
                              (gpt-doc-post-fix)
                              (when callback
                                (funcall callback))))))

;;;###autoload
(defun gpt-doc-stream-result (&optional with-related-defs callback)
  "Generate documentation for Emacs Lisp code.

Optional argument WITH-RELATED-DEFS determines whether to include related
definitions.

If WITH-RELATED-DEFS is 1, no related definitions are included.

If WITH-RELATED-DEFS is 4, shallow related definitions are included.

If WITH-RELATED-DEFS is 16, all related definitions are included.

Optional argument CALLBACK is a function to be called when the documentation
process is completed."
  (interactive "p")
  (pcase-let*
      ((in-progress (gpt-doc-active-p))
       (`(,sexp . ,doc-pos)
        (gpt-doc-get-sexp-with-doc-pos))
       (buff (current-buffer))
       (related-defs
        (and sexp
             doc-pos
             (not in-progress)
             (pcase with-related-defs
               (1 (gpt-doc-get-related-defs sexp))
               (4 (gpt-doc-get-shallow-related-defs sexp))
               (16 (gpt-doc-get-related-defs sexp)))))
       (`(,short-user-prompt . ,short-system-prompt)
        (cons (gpt-doc-make-code-prompt
               sexp
               related-defs)
              (format gpt-doc-return-type-prompt (cadr sexp))))
       (`(,_type ,_name ,old-doc ,beg ,end)
        (gpt-doc-get-current-doc-info)))
    (if in-progress
        (message "gpt-doc: already documenting %s" (cadr sexp))
      (when doc-pos
        (with-current-buffer buff
          (barf-if-buffer-read-only)
          (cond ((and beg end)
                 (goto-char (1- end))
                 (cond ((looking-back "\n\n" 0))
                       ((looking-back "\n" 0)
                        (insert "\n"))
                       (t (insert "\n\n"))))
                (t (goto-char doc-pos)
                   (if (looking-back "\n[\s\t]*" 0)
                       (indent-according-to-mode)
                     (newline-and-indent))
                   (insert (propertize (prin1-to-string "") 'gpt-doc "gpt-doc"
                                       'gpt-doc-old old-doc))
                   (forward-char -1)))
          (gpt-doc-stream-request
           short-user-prompt
           short-system-prompt
           (lambda ()
             (gpt-doc-post-fix)
             (when callback
               (funcall callback)))))))))

(defun gpt-doc--pre-init ()
  "Replace old documentation with new GPT-generated content."
  (pcase-let* ((`(,_sexp . ,doc-pos)
                (gpt-doc-get-sexp-with-doc-pos))
               (`(,_type ,_name ,old-doc ,beg ,end)
                (gpt-doc-get-current-doc-info)))
    (when doc-pos
      (cond ((and beg end)
             (goto-char beg)
             (delete-region beg end))
            (t
             (goto-char doc-pos)))
      (cond ((looking-at "\n\n")
             (forward-line 1)
             (indent-according-to-mode))
            ((looking-back "\n[\s\t]*" 0)
             (indent-according-to-mode))
            (t (newline-and-indent)))
      (insert (propertize (prin1-to-string "") 'gpt-doc "gpt-doc"
                          'gpt-doc-old (or old-doc t)))
      (forward-char -1))))

(defun gpt-doc-jump-to-last-valid-sexp (&optional undocumented)
  "Jump to the last valid S-expression.

Optional argument UNDOCUMENTED is a boolean flag indicating whether to jump to
the last valid sexp that lacks documentation. If non-nil, the function will
consider sexps without documentation; otherwise, it defaults to considering all
sexps."
  (goto-char (point-max))
  (gpt-doc-move-with #'backward-list)
  (while
      (when (or
             (pcase-let ((`(,item-type ,_n ,doc ,_end)
                          (gpt-doc-get-current-doc-info)))
               (or (not item-type)
                   (when undocumented
                     (stringp doc))))
             (gpt-doc-active-p))
        (gpt-doc-move-with #'backward-list)))
  (not (or
        (pcase-let ((`(,item-type ,_n ,doc ,_end)
                     (gpt-doc-get-current-doc-info)))
          (or (not item-type)
              (when undocumented
                (stringp doc))))
        (gpt-doc-active-p))))

(defun gpt-doc-backward-to-undocumented ()
  "Navigate backward to the first undocumented element."
  (when-let* ((start (gpt-doc-get-curr-sexp-start)))
    (gpt-doc-goto-char start))
  (while
      (when (or (pcase-let ((`(,item-type ,_n ,doc ,_end)
                             (gpt-doc-get-current-doc-info)))
                  (or (not item-type)
                      (stringp doc)))
                (gpt-doc-active-p))
        (gpt-doc-move-with #'backward-list)))
  (pcase-let ((`(,item-type ,_n ,doc ,_end)
               (gpt-doc-get-current-doc-info)))
    (and item-type
         (not doc)
         (not (gpt-doc-active-p)))))

;;;###autoload
(defun gpt-doc-abort-all ()
  "Terminate the process associated with a buffer BUFF and delete its buffer.

Argument BUFF is the buffer in which the process to be aborted is running."
  (interactive)
  (gpt-doc--abort-all))

;;;###autoload
(defun gpt-doc-regenerate-dups (&optional with-related-defs)
  "Regenerate documenations for definitions with duplicated documentation strings.

Optional prefix argument WITH-RELATED-DEFS determines the inclusion of related
definitions to the system prompt as additional context:

If WITH-RELATED-DEFS is omitted, `gpt-doc-default-context-strategy'
will be used as default.

- If WITH-RELATED-DEFS is 1, no related definitions are included.
- If WITH-RELATED-DEFS is 4 (shallow), include related definitions that are
  directly used in the definition being documented (e.g., functions called
  within the function).
- If WITH-RELATED-DEFS is 16 (all), recursively include all related definitions,
  expanding the documentation context."
  (interactive "P")
  (let* ((buffer (current-buffer))
         (markers (mapcar (pcase-lambda
                            (`(,_type ,_name ,_doc-str ,beg ,_end))
                            (set-marker (make-marker) beg buffer))
                          (cdar (gpt-doc-collect-doc-dups))))
         (marker))
    (save-excursion
      (while (setq marker (pop markers))
        (goto-char marker)
        (let ((callback
               (unless markers
                 (lambda ()
                   (gpt-doc-regenerate-dups
                    with-related-defs)))))
          (gpt-doc-stream (or (car-safe with-related-defs)
                              gpt-doc-default-context-strategy)
                          callback))))))

;;;###autoload
(defun gpt-doc-document-all-undocumented (&optional with-related-defs here)
  "Generate documentation for all undocumented definitions in the buffer.

Optional prefix argument WITH-RELATED-DEFS determines the inclusion of related
definitions to the system prompt as additional context:

If WITH-RELATED-DEFS is omitted, `gpt-doc-default-context-strategy'
will be used as default.

- If WITH-RELATED-DEFS is 1, no related definitions are included.

- If WITH-RELATED-DEFS is 4 (shallow), include related definitions that are
  directly used in the definition being documented (e.g., functions called
  within the function).

- If WITH-RELATED-DEFS is 16 (all), recursively include all related
  definitions,expanding the documentation context.

Optional argument HERE is a boolean flag indicating whether to jump to the last
valid sexp that lacks documentation. If non-nil, the function will consider
sexps without documentation; otherwise, it defaults to considering all sexps."
  (interactive "P")
  (if here
      (gpt-doc-backward-to-undocumented)
    (gpt-doc-jump-to-last-valid-sexp t))
  (when-let* ((start (gpt-doc-get-curr-sexp-start)))
    (gpt-doc-goto-char start)
    (let ((prev-marker (set-marker (make-marker)
                                   (point))))
      (gpt-doc-stream (or (car-safe with-related-defs)
                          gpt-doc-default-context-strategy)
                      (lambda ()
                        (let ((buffer (marker-buffer prev-marker)))
                          (when (buffer-live-p buffer)
                            (with-current-buffer
                                buffer
                              (gpt-doc-goto-char prev-marker)
                              (let ((prev-pos (point)))
                                (when (gpt-doc-backward-to-undocumented)
                                  (when (not (equal (point)
                                                    prev-pos))
                                    (gpt-doc-document-all-undocumented
                                     with-related-defs
                                     t))))))))))))

;;;###autoload
(defun gpt-doc-redocument-all (&optional with-related-defs here)
  "Redocument all definitions backward from HERE in current buffer.

Optional argument HERE is a boolean flag indicating whether to jump to the last
valid sexp if the current sexp is not suitable.

Optional prefix argument WITH-RELATED-DEFS determines the inclusion of related
definitions to the system prompt as additional context:

If WITH-RELATED-DEFS is omitted, `gpt-doc-default-context-strategy'
will be used as default.

- If WITH-RELATED-DEFS is 1, no related definitions are included.
- If WITH-RELATED-DEFS is 4 (shallow), include related definitions that are
  directly used in the definition being documented (e.g., functions called
  within the function).
- If WITH-RELATED-DEFS is 16 (all), recursively include all related definitions,
  expanding the documentation context.

When streaming, requests can be aborted with command `gpt-doc-abort-all'."
  (interactive "P")
  (when-let* ((start (or (gpt-doc-get-curr-sexp-start)
                        (and
                         (not here)
                         (gpt-doc-jump-to-last-valid-sexp)
                         (gpt-doc-get-curr-sexp-start)))))
    (gpt-doc-goto-char start)
    (let ((prev-marker (set-marker (make-marker)
                                   (point))))
      (gpt-doc-stream (or (car-safe with-related-defs)
                          gpt-doc-default-context-strategy)
                      (lambda ()
                        (let ((buffer (marker-buffer prev-marker)))
                          (when (buffer-live-p buffer)
                            (with-current-buffer
                                buffer
                              (gpt-doc-goto-char prev-marker)
                              (let ((prev-pos))
                                (while
                                    (and (gpt-doc-move-with #'backward-list)
                                         (not (gpt-doc-get-sexp-with-doc-pos))
                                         (not (gpt-doc-active-p))))
                                (setq prev-pos (point))
                                (when (and prev-pos
                                           (not (equal (marker-position
                                                        prev-marker)
                                                       prev-pos))
                                           (gpt-doc-get-sexp-with-doc-pos)
                                           (not (gpt-doc-active-p)))
                                  (gpt-doc-goto-char prev-pos)
                                  (gpt-doc-redocument-all
                                   with-related-defs
                                   t)))))))))))

;;;###autoload
(defun gpt-doc-stream (&optional with-related-defs callback)
  "Stream the documentation of the current definition.

Generate and insert the documentation piece by piece as it is available,
allowing for progressive display without waiting for the complete information.

Optional argument WITH-RELATED-DEFS determines the inclusion of related
definitions to the system prompt for generating documentation:

- If WITH-RELATED-DEFS is 1, no related definitions are included.
- If WITH-RELATED-DEFS is 4 (shallow), include related definitions that are
  directly used in the definition being documented (e.g., functions called
  within the function).
- If WITH-RELATED-DEFS is 16 (all), recursively include all related definitions,
  expanding the documentation context.

If documentation is in progress for the current element, notify the user.
Otherwise, begin generating and inserting documentation at the determined
position.

CALLBACK, if provided, is an optional function called upon completion without
arguments. This can be useful for triggering additional actions after
documentation generation.

Call this function interactively with a numeric prefix argument to specify the
level of related definitions inclusion.

During streaming, active requests in the buffer can be aborted with command
`gpt-doc-abort-all'."
  (interactive "p")
  (pcase-let*
      ((in-progress (gpt-doc-active-p))
       (`(,sexp . ,doc-pos)
        (gpt-doc-get-sexp-with-doc-pos))
       (buff (current-buffer))
       (related-defs
        (and sexp
             doc-pos
             (not in-progress)
             (gpt-doc-get-related-definitions sexp
                                              with-related-defs)))
       (user-prompt (gpt-doc-make-code-prompt sexp
                                              related-defs))
       (system-summary-prompt (gpt-doc--get-system-prompt-for-summary sexp))
       (system-args-prompt (gpt-doc-get-system-prompt-for-args sexp)))
    (if in-progress
        (message "gpt-doc: already documenting %s" (cadr sexp))
      (when doc-pos
        (with-current-buffer buff
          (barf-if-buffer-read-only)
          (gpt-doc--pre-init)
          (when gpt-doc-allow-abort-mode
            (gpt-doc-mode 1))
          (gpt-doc-stream-request
           user-prompt
           system-summary-prompt
           (lambda ()
             (if system-args-prompt
                 (funcall #'gpt-doc-arg-system-prompt user-prompt
                          system-args-prompt
                          callback)
               (gpt-doc-post-fix)
               (when callback
                 (funcall callback))))))))))

;;;###autoload
(defun gpt-doc-document-current-function (&optional with-related-defs)
  "Generate documentation for the thing at point synchronously.

If prefix argument WITH-RELATED-DEFS is omitted or (16), recursively
include all related definitions, expanding the documentation context.

- If WITH-RELATED-DEFS is 1, no related definitions are included.
- If WITH-RELATED-DEFS is 4 (shallow), include related definitions that are
  directly used in the definition being documented (e.g., functions called
  within the function).
- If WITH-RELATED-DEFS is 16 (all), recursively include all related definitions,
  expanding the documentation context."
  (interactive "p")
  (pcase-let*
      ((`(,sexp . ,doc-pos)
        (gpt-doc-get-sexp-with-doc-pos))
       (buff (current-buffer))
       (related-defs
        (and sexp
             doc-pos
             (pcase with-related-defs
               (1 nil)
               (4 (gpt-doc-get-shallow-related-defs sexp))
               (16 (gpt-doc-get-related-defs sexp)))))
       (text
        (gpt-doc-document-sexp sexp related-defs)))
    (when (and text doc-pos)
      (with-current-buffer buff
        (if buffer-read-only
            (message "%s" text)
          (save-excursion
            (goto-char doc-pos)
            (if (looking-back "\n" 0)
                (indent-according-to-mode)
              (newline-and-indent))
            (insert (prin1-to-string text))
            (forward-sexp -1)
            (forward-char 1)))))))

;;;###autoload
(defalias 'gpt-doc-sync #'gpt-doc-document-current-function
  "Generate documentation for the current definition in the buffer synchronously.

If prefix argument WITH-RELATED-DEFS is omitted or (16), recursively
include all related definitions, expanding the documentation context.

- If WITH-RELATED-DEFS is 1, no related definitions are included.
- If WITH-RELATED-DEFS is 4 (shallow), include related definitions that are
  directly used in the definition being documented (e.g., functions called
  within the function).
- If WITH-RELATED-DEFS is 16 (all), recursively include all related definitions,
  expanding the documentation context.")

;;;###autoload
(defun gpt-doc-with-full-context (&optional with-related-defs)
  "Document thing at point by incorporating all used functions into the prompt.

If prefix argument WITH-RELATED-DEFS is omitted or (16), recursively
include all related definitions, expanding the documentation context.

- If WITH-RELATED-DEFS is 1, no related definitions are included.
- If WITH-RELATED-DEFS is 4 (shallow), include related definitions that are
  directly used in the definition being documented (e.g., functions called
  within the function).

Use streaming if `gpt-doc-use-stream' is non-nil, otherwise perform a
synchronous request.

When streaming, requests can be aborted with command `gpt-doc-abort-all'."
  (interactive "P")
  (funcall (if gpt-doc-use-stream
               #'gpt-doc-stream
             #'gpt-doc-document-current-function)
           (or (car-safe with-related-defs) 16)))

;;;###autoload
(defun gpt-doc-with-context (&optional with-related-defs)
  "Document thing at point by incorporating used functions into the prompt.

Optional prefix argument WITH-RELATED-DEFS determines whether to include related
definitions to the GPT context message.

- If WITH-RELATED-DEFS is nil or (4) (shallow), include related definitions
  that are directly used in the definition being documented (e.g., functions
  called within the function).
- If WITH-RELATED-DEFS is 1, no related definitions are included.
- If WITH-RELATED-DEFS is 16 (all), recursively include all related definitions,
  expanding the documentation context.

Use streaming if `gpt-doc-use-stream' is non-nil, otherwise perform a
synchronous request.

During streaming, active requests can be aborted with command
`gpt-doc-abort-all'."
  (interactive "P")
  (funcall (if gpt-doc-use-stream
               #'gpt-doc-stream
             #'gpt-doc-document-current-function)
           (or (car-safe with-related-defs) 4)))

;;;###autoload
(defun gpt-doc (&optional with-related-defs)
  "Generate and insert documentation for a definition at point using GPT.

Optional prefix argument WITH-RELATED-DEFS determines the inclusion of related
definitions to the system prompt as additional context:

If WITH-RELATED-DEFS is omitted, `gpt-doc-default-context-strategy'
will be used as default.

- If WITH-RELATED-DEFS is 1, no related definitions are included.
- If WITH-RELATED-DEFS is 4 (shallow), include related definitions that are
  directly used in the definition being documented (e.g., functions called
  within the function).
- If WITH-RELATED-DEFS is 16 (all), recursively include all related definitions,
  expanding the documentation context.

If `gpt-doc-use-stream' is non-nil, generate and insert
the documentation piece by piece as it is available, otherwise perform a
synchronous request.

During streaming, active requests can be aborted with command
`gpt-doc-abort-all'."
  (interactive "P")
  (funcall (if gpt-doc-use-stream
               #'gpt-doc-stream
             #'gpt-doc-document-current-function)
           (or (car-safe with-related-defs)
               gpt-doc-default-context-strategy)))

(provide 'gpt-doc)
;;; gpt-doc.el ends here
